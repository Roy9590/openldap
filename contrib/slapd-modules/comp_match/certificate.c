/*
 *    certificate.c
 *    "AuthenticationFramework" ASN.1 module encode/decode/extracting/matching/free C src.
 *    This file was generated by modified eSMACC compiler Sat Oct 23 20:25:08 2004
 *    The generated files are supposed to be compiled as a module for OpenLDAP Software
 */

#include "certificate.h"


void init_module_AuthenticationFramework() {
	add_OD_entry ( "2.5.4.36", GDecComponentCertificate,
	BDecComponentCertificate, NULL);
	InitAnyAuthenticationFramework();
}

void InitAnyAuthenticationFramework()
{
    AsnOid oid0 ={ 9, "\52\206\110\206\367\15\1\1\4" };
    AsnOid oid1 ={ 9, "\52\206\110\206\367\15\1\1\1" };
    AsnOid oid2 ={ 3, "\125\4\6" };


    InstallAnyByComponentOid (nullOid_ANY_ID, &oid0, sizeof (ComponentNull), (EncodeFcn)BEncAsnNull, (gser_decoder_func*)GDecComponentNull, (ber_tag_decoder_func*)BDecComponentNullTag, (ExtractFcn)NULL,(MatchFcn)MatchingComponentNull,(FreeFcn)FreeComponentNull, (PrintFcn)NULL);

    InstallAnyByComponentOid (nullOid2_ANY_ID, &oid1, sizeof (ComponentNull), (EncodeFcn)BEncAsnNull, (gser_decoder_func*)GDecComponentNull, (ber_tag_decoder_func*)BDecComponentNullTag, (ExtractFcn)NULL,(MatchFcn)MatchingComponentNull,(FreeFcn)FreeComponentNull, (PrintFcn)NULL);

    InstallAnyByComponentOid (printableStringOid_ANY_ID, &oid2, sizeof (ComponentPrintableString), (EncodeFcn)BEncPrintableString, (gser_decoder_func*)GDecComponentPrintableString, (ber_tag_decoder_func*)BDecComponentPrintableStringTag, (ExtractFcn)NULL,(MatchFcn)MatchingComponentPrintableString,(FreeFcn)FreeComponentPrintableString, (PrintFcn)NULL);

}  /* InitAnyAuthenticationFramework */


int
MatchingComponentAlgorithmIdentifier ( char* oid, ComponentSyntaxInfo* csi_attr, ComponentSyntaxInfo* csi_assert ) {
	int rc;
	MatchingRule* mr;

	if ( oid ) {
		mr = retrieve_matching_rule( oid, csi_attr->csi_comp_desc->cd_type_id);
		if ( mr ) return component_value_match( mr, csi_attr, csi_assert );
	}

	rc = 1;
	rc =	MatchingComponentOid ( oid, (ComponentSyntaxInfo*)&((ComponentAlgorithmIdentifier*)csi_attr)->algorithm, (ComponentSyntaxInfo*)&((ComponentAlgorithmIdentifier*)csi_assert)->algorithm );
	if ( rc != LDAP_COMPARE_TRUE )
		return rc;
	rc =	SetAnyTypeByComponentOid ((ComponentSyntaxInfo*)&((ComponentAlgorithmIdentifier*)csi_attr)->parameters, (&((ComponentAlgorithmIdentifier*)csi_attr)->algorithm));
	rc = MatchingComponentAnyDefinedBy ( oid, (ComponentSyntaxInfo*)&((ComponentAlgorithmIdentifier*)csi_attr)->parameters, (ComponentSyntaxInfo*)&((ComponentAlgorithmIdentifier*)csi_assert)->parameters);
	if ( rc != LDAP_COMPARE_TRUE )
		return rc;
	return LDAP_COMPARE_TRUE;
}  /* BMatchingComponentAlgorithmIdentifier */

void*
ExtractingComponentAlgorithmIdentifier ( ComponentReference* cr, ComponentAlgorithmIdentifier *comp )
{

	if ( ( strncmp(comp->algorithm.identifier.bv_val, cr->cr_curr->ci_val.ci_identifier.bv_val,cr->cr_curr->ci_val.ci_identifier.bv_len) == 0 ) || ( strncmp(comp->algorithm.id_buf, cr->cr_curr->ci_val.ci_identifier.bv_val,cr->cr_curr->ci_val.ci_identifier.bv_len) == 0 ) ) {
		if ( cr->cr_curr->ci_next == NULL )
		return &comp->algorithm;
		else
		return NULL;
	}
	if ( ( strncmp(comp->parameters.identifier.bv_val, cr->cr_curr->ci_val.ci_identifier.bv_val,cr->cr_curr->ci_val.ci_identifier.bv_len) == 0 ) || ( strncmp(comp->parameters.id_buf, cr->cr_curr->ci_val.ci_identifier.bv_val,cr->cr_curr->ci_val.ci_identifier.bv_len) == 0 ) ) {
		if ( cr->cr_curr->ci_next == NULL )
		return &comp->parameters;
		else
		return NULL;
	}
	return NULL;
}  /* ExtractingComponentAlgorithmIdentifier */

int
BDecComponentAlgorithmIdentifier PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, mode),
GenBuf * b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
ComponentAlgorithmIdentifier **v _AND_
AsnLen *bytesDecoded _AND_
int mode)
{
    int seqDone = FALSE, old_mode = mode;
	AsnLen totalElmtsLen1 = 0;
	AsnLen elmtLen1;
	AsnTag tagId1;
	int mandatoryElmtCount1 = 0;
	ComponentAlgorithmIdentifier *k, *t, c_temp;


	if ( !(mode & DEC_ALLOC_MODE_1) ) {
	memset(&c_temp,0,sizeof(c_temp));
		 k = &c_temp;
	} else
		 k = t = *v;
	mode = DEC_ALLOC_MODE_2;
    tagId1 = BDecTag (b, &totalElmtsLen1 );

    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, OID_TAG_CODE))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1 );
	BDecComponentOid (b, tagId1, elmtLen1, (&k->algorithm), &totalElmtsLen1, mode);
		(&k->algorithm)->identifier.bv_val = (&k->algorithm)->id_buf;
		(&k->algorithm)->identifier.bv_len = strlen("algorithm");
		strcpy( (&k->algorithm)->identifier.bv_val, "algorithm");
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
         tagId1 = BufPeekByte (b);
         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDecEoc (b, &totalElmtsLen1 );
            seqDone = TRUE;
        }
    }
    }
    else
        return -1;



    if (!seqDone)    {
    SetAnyTypeByComponentOid ((&k->parameters), (&k->algorithm));
    BDecComponentAnyDefinedBy (b, (&k->parameters), &totalElmtsLen1, mode );
		(&k->parameters)->identifier.bv_val = (&k->parameters)->id_buf;
		(&k->parameters)->identifier.bv_len = strlen("parameters");
		strcpy( (&k->parameters)->identifier.bv_val, "parameters");
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1 );
        else if (totalElmtsLen1 != elmtLen0)
        return -1;

    }


    if (!seqDone)
        return -1;

	if( !(old_mode & DEC_ALLOC_MODE_1) ) {
	*v = t = (ComponentAlgorithmIdentifier*) malloc( sizeof(ComponentAlgorithmIdentifier) );
	if ( !t ) return -1;
	*t = *k;
	}
	t->syntax = (Syntax*)NULL;
	t->comp_desc = malloc( sizeof( ComponentDesc ) );
	if ( !t->comp_desc ) {
		free ( t );
		return -1;
	}
	t->comp_desc->cd_gser_decoder = (gser_decoder_func*)GDecComponentAlgorithmIdentifier ;
	t->comp_desc->cd_ber_decoder = (ber_decoder_func*)BDecComponentAlgorithmIdentifier ;
	t->comp_desc->cd_free = (comp_free_func*)FreeComponentAlgorithmIdentifier ;
	t->comp_desc->cd_extract_i = (extract_component_from_id_func*)ExtractingComponentAlgorithmIdentifier;
	t->comp_desc->cd_type = ASN_COMPOSITE;
	t->comp_desc->cd_type_id = COMPOSITE_ASN1_TYPE;
	t->comp_desc->cd_all_match = (allcomponent_matching_func*)MatchingComponentAlgorithmIdentifier;
    (*bytesDecoded) += totalElmtsLen1;
	return LDAP_SUCCESS;
}  /* BDecAlgorithmIdentifier*/

int
GDecComponentAlgorithmIdentifier PARAMS ((b, v, bytesDecoded, mode),
GenBuf * b _AND_
ComponentAlgorithmIdentifier **v _AND_
AsnLen *bytesDecoded _AND_
int mode)
{
	char* peek_head,*peek_head2;
	int i, strLen,strLen2, rc, old_mode = mode;
	ComponentAlgorithmIdentifier *k,*t, c_temp;


	if ( !(mode & DEC_ALLOC_MODE_1) ) {
	memset(&c_temp,0,sizeof(c_temp));
		 k = &c_temp;
	} else
		 k = t = *v;
	mode = DEC_ALLOC_MODE_2;
	*bytesDecoded = 0;
	if( !(strLen = LocateNextGSERToken(b,&peek_head,GSER_NO_COPY)) ){
		Asn1Error("Error during Reading , in encoded data");
		return LDAP_PROTOCOL_ERROR;
	}
	if(*peek_head != '{'){
		Asn1Error("Missing { in encoded data");
		return LDAP_PROTOCOL_ERROR;
	}
	if( !(strLen = LocateNextGSERToken(b,&peek_head,GSER_NO_COPY)) ){
	  Asn1Error("Error during Reading identifier");
		return LDAP_PROTOCOL_ERROR;
	}
	GDecComponentOid (b, (&k->algorithm), bytesDecoded, mode);
	(&k->algorithm)->identifier.bv_val = peek_head;
	(&k->algorithm)->identifier.bv_len = strLen;
	if( !(strLen = LocateNextGSERToken(b,&peek_head,GSER_NO_COPY)) ){
		Asn1Error("Error during Reading { ");
		return LDAP_PROTOCOL_ERROR;
	}
	if(*peek_head != ','){
		Asn1Error("Missing , in encoding");
		return LDAP_PROTOCOL_ERROR;
	}
	if( !(strLen = LocateNextGSERToken(b,&peek_head,GSER_NO_COPY)) ){
	  Asn1Error("Error during Reading identifier");
		return LDAP_PROTOCOL_ERROR;
	}
    SetAnyTypeByComponentOid ((&k->parameters), (&k->algorithm));
    GDecComponentAnyDefinedBy (b, (&k->parameters), bytesDecoded, mode );
	(&k->parameters)->identifier.bv_val = peek_head;
	(&k->parameters)->identifier.bv_len = strLen;
	if( !(strLen = LocateNextGSERToken(b,&peek_head,GSER_NO_COPY)) ) {
		Asn1Error("Error during Reading } in encoding");
		return LDAP_PROTOCOL_ERROR;
	}
	if(*peek_head != '}'){
		Asn1Error("Missing } in encoding");
		return LDAP_PROTOCOL_ERROR;
	}
	if( !(old_mode & DEC_ALLOC_MODE_1) ) {
	*v = t = (ComponentAlgorithmIdentifier*) malloc( sizeof(ComponentAlgorithmIdentifier) );
	if ( !t ) return -1;
	*t = *k;
	}
	t->syntax = (Syntax*)NULL;
	t->comp_desc = malloc( sizeof( ComponentDesc ) );
	if ( !t->comp_desc ) {
		free ( t );
		return -1;
	}
	t->comp_desc->cd_gser_decoder = (gser_decoder_func*)GDecComponentAlgorithmIdentifier ;
	t->comp_desc->cd_ber_decoder = (ber_decoder_func*)BDecComponentAlgorithmIdentifier ;
	t->comp_desc->cd_free = (comp_free_func*)FreeComponentAlgorithmIdentifier ;
	t->comp_desc->cd_extract_i = (extract_component_from_id_func*)ExtractingComponentAlgorithmIdentifier;
	t->comp_desc->cd_type = ASN_COMPOSITE;
	t->comp_desc->cd_type_id = COMPOSITE_ASN1_TYPE;
	t->comp_desc->cd_all_match = (allcomponent_matching_func*)MatchingComponentAlgorithmIdentifier;
	return LDAP_SUCCESS;
}  /* GDecAlgorithmIdentifier*/

void FreeComponentAlgorithmIdentifier(ComponentAlgorithmIdentifier *v)
{

	if(v == NULL)
		return;
	FreeComponentOid((&v->algorithm));
	free ((v->algorithm).comp_desc);

	if(COMPONENTNOT_NULL ((&v->parameters)))
    {
	FreeComponentAnyDefinedBy((&v->parameters));
	free ((v->parameters).comp_desc);

	}

}  /* FreeAlgorithmIdentifier */


int
MatchingComponentTime ( char* oid, ComponentSyntaxInfo* csi_attr, ComponentSyntaxInfo* csi_assert ) {
	int rc;
	MatchingRule* mr;
	ComponentTime *v1, *v2;


	v1 = (ComponentTime*)csi_attr;
	v2 = (ComponentTime*)csi_assert;
	if ( oid ) {
		mr = retrieve_matching_rule( oid, csi_attr->csi_comp_desc->cd_type_id);
		if ( mr ) return component_value_match( mr, csi_attr, csi_assert );
	}

	if( (v1->choiceId != v2->choiceId ) )
		return LDAP_COMPARE_FALSE;
	switch( v1->choiceId )
	{
	   case TIME_UTCTIME :
		rc = 	MatchingComponentUTCTime ( oid, (ComponentSyntaxInfo*)(v1->a.utcTime), (ComponentSyntaxInfo*)(v2->a.utcTime) );
		break;
	   case TIME_GENERALIZEDTIME :
		rc = 	MatchingComponentGeneralizedTime ( oid, (ComponentSyntaxInfo*)(v1->a.generalizedTime), (ComponentSyntaxInfo*)(v2->a.generalizedTime) );
		break;
	default : 
		 return LDAP_PROTOCOL_ERROR;
	}
	return rc;
}  /* BMatchingComponentTimeContent */

void*
ExtractingComponentTime ( ComponentReference* cr, ComponentTime *comp )
{


	if( (comp->choiceId) ==  TIME_UTCTIME &&
		 ((strncmp(comp->a.utcTime->identifier.bv_val, cr->cr_curr->ci_val.ci_identifier.bv_val,cr->cr_curr->ci_val.ci_identifier.bv_len) == 0) ||
		 ( strncmp(comp->a.utcTime->id_buf, cr->cr_curr->ci_val.ci_identifier.bv_val,cr->cr_curr->ci_val.ci_identifier.bv_len) == 0))) {
		if ( cr->cr_curr->ci_next == NULL )
			return (comp->a.utcTime);
		else {
			cr->cr_curr = cr->cr_curr->ci_next;
			return 	ExtractingComponentUTCTime ( cr, (comp->a.utcTime) );
		};
	}
	if( (comp->choiceId) ==  TIME_GENERALIZEDTIME &&
		 ((strncmp(comp->a.generalizedTime->identifier.bv_val, cr->cr_curr->ci_val.ci_identifier.bv_val,cr->cr_curr->ci_val.ci_identifier.bv_len) == 0) ||
		 ( strncmp(comp->a.generalizedTime->id_buf, cr->cr_curr->ci_val.ci_identifier.bv_val,cr->cr_curr->ci_val.ci_identifier.bv_len) == 0))) {
		if ( cr->cr_curr->ci_next == NULL )
			return (comp->a.generalizedTime);
		else {
			cr->cr_curr = cr->cr_curr->ci_next;
			return 	ExtractingComponentGeneralizedTime ( cr, (comp->a.generalizedTime) );
		};
	}
	return NULL;
}  /* ExtractingComponentTime */

int
BDecComponentTime PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, mode),
GenBuf * b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
ComponentTime **v _AND_
AsnLen *bytesDecoded _AND_
int mode)
{
    int seqDone = FALSE, old_mode = mode;
	AsnLen totalElmtsLen1 = 0;
	AsnLen elmtLen1;
	AsnTag tagId1;
	int mandatoryElmtCount1 = 0;
	ComponentTime *k, *t, c_temp;


	if ( !(mode & DEC_ALLOC_MODE_1) ) {
	memset(&c_temp,0,sizeof(c_temp));
		 k = &c_temp;
	} else
		 k = t = *v;
	mode = DEC_ALLOC_MODE_2;
    switch (tagId0)
    {
       case MAKE_TAG_ID (UNIV, PRIM, UTCTIME_TAG_CODE):
       case MAKE_TAG_ID (UNIV, CONS, UTCTIME_TAG_CODE):
        (k->choiceId) = TIME_UTCTIME;
	BDecComponentUTCTime (b, tagId0, elmtLen0, (&k->a.utcTime), &totalElmtsLen1, DEC_ALLOC_MODE_0 );
		(k->a.utcTime)->identifier.bv_val = (k->a.utcTime)->id_buf;
		(k->a.utcTime)->identifier.bv_len = strlen("utcTime");
		strcpy( (k->a.utcTime)->identifier.bv_val, "utcTime");
    break;

       case MAKE_TAG_ID (UNIV, PRIM, GENERALIZEDTIME_TAG_CODE):
       case MAKE_TAG_ID (UNIV, CONS, GENERALIZEDTIME_TAG_CODE):
        (k->choiceId) = TIME_GENERALIZEDTIME;
	BDecComponentGeneralizedTime (b, tagId0, elmtLen0, (&k->a.generalizedTime), &totalElmtsLen1, DEC_ALLOC_MODE_0 );
		(k->a.generalizedTime)->identifier.bv_val = (k->a.generalizedTime)->id_buf;
		(k->a.generalizedTime)->identifier.bv_len = strlen("generalizedTime");
		strcpy( (k->a.generalizedTime)->identifier.bv_val, "generalizedTime");
    break;

    default:
        Asn1Error ("ERROR - unexpected tag in CHOICE\n");
        return -1;
        break;
    } /* end switch */
	if( !(old_mode & DEC_ALLOC_MODE_1) ) {
	*v = t = (ComponentTime*) malloc( sizeof(ComponentTime) );
	if ( !t ) return -1;
	*t = *k;
	}
	t->syntax = (Syntax*)NULL;
	t->comp_desc = malloc( sizeof( ComponentDesc ) );
	if ( !t->comp_desc ) {
		free ( t );
		return -1;
	}
	t->comp_desc->cd_gser_decoder = (gser_decoder_func*)GDecComponentTime ;
	t->comp_desc->cd_ber_decoder = (ber_decoder_func*)BDecComponentTime ;
	t->comp_desc->cd_free = (comp_free_func*)FreeComponentTime ;
	t->comp_desc->cd_extract_i = (extract_component_from_id_func*)ExtractingComponentTime;
	t->comp_desc->cd_type = ASN_COMPOSITE;
	t->comp_desc->cd_type_id = COMPOSITE_ASN1_TYPE;
	t->comp_desc->cd_all_match = (allcomponent_matching_func*)MatchingComponentTime;
    (*bytesDecoded) += totalElmtsLen1;
	return LDAP_SUCCESS;
}  /* BDecTimeContent */

int
GDecComponentTime PARAMS ((b, v, bytesDecoded, mode),
GenBuf * b _AND_
ComponentTime **v _AND_
AsnLen *bytesDecoded _AND_
int mode)
{
	char* peek_head,*peek_head2;
	int i, strLen,strLen2, rc, old_mode = mode;
	ComponentTime *k,*t, c_temp;


	if ( !(mode & DEC_ALLOC_MODE_1) ) {
	memset(&c_temp,0,sizeof(c_temp));
		 k = &c_temp;
	} else
		 k = t = *v;
	mode = DEC_ALLOC_MODE_2;
	if( !(strLen = LocateNextGSERToken(b,&peek_head,GSER_NO_COPY)) ){
		Asn1Error("Error during Reading identifier");
		return LDAP_PROTOCOL_ERROR;
	}
	if( !(strLen2 = LocateNextGSERToken(b,&peek_head2,GSER_NO_COPY)) ){
		Asn1Error("Error during Reading identifier");
		return LDAP_PROTOCOL_ERROR;
	}
	if(*peek_head2 != ':'){
		Asn1Error("Missing : in encoded data");
		return LDAP_PROTOCOL_ERROR;
	}
	if( strncmp("utcTime",peek_head,sizeof("utcTime")-1) == 0){
		(k->choiceId) = TIME_UTCTIME;
		rc = 	GDecComponentUTCTime (b, (&k->a.utcTime), bytesDecoded, DEC_ALLOC_MODE_0 );
		if ( rc != LDAP_SUCCESS ) return rc;
		(k->a.utcTime)->identifier.bv_val = peek_head;
		(k->a.utcTime)->identifier.bv_len = strLen;
	}
	else if( strncmp("generalizedTime",peek_head,sizeof("generalizedTime")-1) == 0){
		(k->choiceId) = TIME_GENERALIZEDTIME;
		rc = 	GDecComponentGeneralizedTime (b, (&k->a.generalizedTime), bytesDecoded, DEC_ALLOC_MODE_0 );
		if ( rc != LDAP_SUCCESS ) return rc;
		(k->a.generalizedTime)->identifier.bv_val = peek_head;
		(k->a.generalizedTime)->identifier.bv_len = strLen;
	}
	else {
		Asn1Error("Undefined Identifier");
		return LDAP_PROTOCOL_ERROR;
	}
	if( !(old_mode & DEC_ALLOC_MODE_1) ) {
	*v = t = (ComponentTime*) malloc( sizeof(ComponentTime) );
	if ( !t ) return -1;
	*t = *k;
	}
	t->syntax = (Syntax*)NULL;
	t->comp_desc = malloc( sizeof( ComponentDesc ) );
	if ( !t->comp_desc ) {
		free ( t );
		return -1;
	}
	t->comp_desc->cd_gser_decoder = (gser_decoder_func*)GDecComponentTime ;
	t->comp_desc->cd_ber_decoder = (ber_decoder_func*)BDecComponentTime ;
	t->comp_desc->cd_free = (comp_free_func*)FreeComponentTime ;
	t->comp_desc->cd_extract_i = (extract_component_from_id_func*)ExtractingComponentTime;
	t->comp_desc->cd_type = ASN_COMPOSITE;
	t->comp_desc->cd_type_id = COMPOSITE_ASN1_TYPE;
	t->comp_desc->cd_all_match = (allcomponent_matching_func*)MatchingComponentTime;
	return LDAP_SUCCESS;
}  /* GDecTimeContent */

void FreeComponentTime(ComponentTime *v)
{

	if(v == NULL)
		return;
		switch(v->choiceId)
    {
	   case TIME_UTCTIME:
	FreeComponentUTCTime((v->a.utcTime));
	free ((v->a.utcTime)->comp_desc);
	free ((v->a.utcTime));

	break;

	   case TIME_GENERALIZEDTIME:
	FreeComponentGeneralizedTime((v->a.generalizedTime));
	free ((v->a.generalizedTime)->comp_desc);
	free ((v->a.generalizedTime));

	break;

	}
}  /* FreeTime */


int
MatchingComponentExtension ( char* oid, ComponentSyntaxInfo* csi_attr, ComponentSyntaxInfo* csi_assert ) {
	int rc;
	MatchingRule* mr;

	if ( oid ) {
		mr = retrieve_matching_rule( oid, csi_attr->csi_comp_desc->cd_type_id);
		if ( mr ) return component_value_match( mr, csi_attr, csi_assert );
	}

	rc = 1;
	rc =	MatchingComponentOid ( oid, (ComponentSyntaxInfo*)&((ComponentExtension*)csi_attr)->extnID, (ComponentSyntaxInfo*)&((ComponentExtension*)csi_assert)->extnID );
	if ( rc != LDAP_COMPARE_TRUE )
		return rc;
	rc =	MatchingComponentOcts ( oid, (ComponentSyntaxInfo*)&((ComponentExtension*)csi_attr)->extnValue, (ComponentSyntaxInfo*)&((ComponentExtension*)csi_assert)->extnValue );
	if ( rc != LDAP_COMPARE_TRUE )
		return rc;
	return LDAP_COMPARE_TRUE;
}  /* BMatchingComponentExtension */

void*
ExtractingComponentExtension ( ComponentReference* cr, ComponentExtension *comp )
{

	if ( ( strncmp(comp->extnID.identifier.bv_val, cr->cr_curr->ci_val.ci_identifier.bv_val,cr->cr_curr->ci_val.ci_identifier.bv_len) == 0 ) || ( strncmp(comp->extnID.id_buf, cr->cr_curr->ci_val.ci_identifier.bv_val,cr->cr_curr->ci_val.ci_identifier.bv_len) == 0 ) ) {
		if ( cr->cr_curr->ci_next == NULL )
		return &comp->extnID;
		else
		return NULL;
	}
	if ( ( strncmp(comp->extnValue.identifier.bv_val, cr->cr_curr->ci_val.ci_identifier.bv_val,cr->cr_curr->ci_val.ci_identifier.bv_len) == 0 ) || ( strncmp(comp->extnValue.id_buf, cr->cr_curr->ci_val.ci_identifier.bv_val,cr->cr_curr->ci_val.ci_identifier.bv_len) == 0 ) ) {
		if ( cr->cr_curr->ci_next == NULL )
		return &comp->extnValue;
		else
		return NULL;
	}
	return NULL;
}  /* ExtractingComponentExtension */

int
BDecComponentExtension PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, mode),
GenBuf * b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
ComponentExtension **v _AND_
AsnLen *bytesDecoded _AND_
int mode)
{
    int seqDone = FALSE, old_mode = mode;
	AsnLen totalElmtsLen1 = 0;
	AsnLen elmtLen1;
	AsnTag tagId1;
	int mandatoryElmtCount1 = 0;
	ComponentExtension *k, *t, c_temp;


	if ( !(mode & DEC_ALLOC_MODE_1) ) {
	memset(&c_temp,0,sizeof(c_temp));
		 k = &c_temp;
	} else
		 k = t = *v;
	mode = DEC_ALLOC_MODE_2;
    tagId1 = BDecTag (b, &totalElmtsLen1 );

    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, OID_TAG_CODE))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1 );
	BDecComponentOid (b, tagId1, elmtLen1, (&k->extnID), &totalElmtsLen1, mode);
		(&k->extnID)->identifier.bv_val = (&k->extnID)->id_buf;
		(&k->extnID)->identifier.bv_len = strlen("extnID");
		strcpy( (&k->extnID)->identifier.bv_val, "extnID");
    tagId1 = BDecTag (b, &totalElmtsLen1);
    }
    else
        return -1;



    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, OCTETSTRING_TAG_CODE)) ||
(tagId1 == MAKE_TAG_ID (UNIV, CONS, OCTETSTRING_TAG_CODE))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1 );
	BDecComponentOcts (b, tagId1, elmtLen1, (&k->extnValue), &totalElmtsLen1, mode);
		(&k->extnValue)->identifier.bv_val = (&k->extnValue)->id_buf;
		(&k->extnValue)->identifier.bv_len = strlen("extnValue");
		strcpy( (&k->extnValue)->identifier.bv_val, "extnValue");
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1 );
        else if (totalElmtsLen1 != elmtLen0)
        return -1;

    }
    else
        return -1;



    if (!seqDone)
        return -1;

	if( !(old_mode & DEC_ALLOC_MODE_1) ) {
	*v = t = (ComponentExtension*) malloc( sizeof(ComponentExtension) );
	if ( !t ) return -1;
	*t = *k;
	}
	t->syntax = (Syntax*)NULL;
	t->comp_desc = malloc( sizeof( ComponentDesc ) );
	if ( !t->comp_desc ) {
		free ( t );
		return -1;
	}
	t->comp_desc->cd_gser_decoder = (gser_decoder_func*)GDecComponentExtension ;
	t->comp_desc->cd_ber_decoder = (ber_decoder_func*)BDecComponentExtension ;
	t->comp_desc->cd_free = (comp_free_func*)FreeComponentExtension ;
	t->comp_desc->cd_extract_i = (extract_component_from_id_func*)ExtractingComponentExtension;
	t->comp_desc->cd_type = ASN_COMPOSITE;
	t->comp_desc->cd_type_id = COMPOSITE_ASN1_TYPE;
	t->comp_desc->cd_all_match = (allcomponent_matching_func*)MatchingComponentExtension;
    (*bytesDecoded) += totalElmtsLen1;
	return LDAP_SUCCESS;
}  /* BDecExtension*/

int
GDecComponentExtension PARAMS ((b, v, bytesDecoded, mode),
GenBuf * b _AND_
ComponentExtension **v _AND_
AsnLen *bytesDecoded _AND_
int mode)
{
	char* peek_head,*peek_head2;
	int i, strLen,strLen2, rc, old_mode = mode;
	ComponentExtension *k,*t, c_temp;


	if ( !(mode & DEC_ALLOC_MODE_1) ) {
	memset(&c_temp,0,sizeof(c_temp));
		 k = &c_temp;
	} else
		 k = t = *v;
	mode = DEC_ALLOC_MODE_2;
	*bytesDecoded = 0;
	if( !(strLen = LocateNextGSERToken(b,&peek_head,GSER_NO_COPY)) ){
		Asn1Error("Error during Reading , in encoded data");
		return LDAP_PROTOCOL_ERROR;
	}
	if(*peek_head != '{'){
		Asn1Error("Missing { in encoded data");
		return LDAP_PROTOCOL_ERROR;
	}
	if( !(strLen = LocateNextGSERToken(b,&peek_head,GSER_NO_COPY)) ){
	  Asn1Error("Error during Reading identifier");
		return LDAP_PROTOCOL_ERROR;
	}
	GDecComponentOid (b, (&k->extnID), bytesDecoded, mode);
	(&k->extnID)->identifier.bv_val = peek_head;
	(&k->extnID)->identifier.bv_len = strLen;
	if( !(strLen = LocateNextGSERToken(b,&peek_head,GSER_NO_COPY)) ){
		Asn1Error("Error during Reading { ");
		return LDAP_PROTOCOL_ERROR;
	}
	if(*peek_head != ','){
		Asn1Error("Missing , in encoding");
		return LDAP_PROTOCOL_ERROR;
	}
	if( !(strLen = LocateNextGSERToken(b,&peek_head,GSER_NO_COPY)) ){
	  Asn1Error("Error during Reading identifier");
		return LDAP_PROTOCOL_ERROR;
	}
	GDecComponentOcts (b, (&k->extnValue), bytesDecoded, mode);
	(&k->extnValue)->identifier.bv_val = peek_head;
	(&k->extnValue)->identifier.bv_len = strLen;
	if( !(strLen = LocateNextGSERToken(b,&peek_head,GSER_NO_COPY)) ) {
		Asn1Error("Error during Reading } in encoding");
		return LDAP_PROTOCOL_ERROR;
	}
	if(*peek_head != '}'){
		Asn1Error("Missing } in encoding");
		return LDAP_PROTOCOL_ERROR;
	}
	if( !(old_mode & DEC_ALLOC_MODE_1) ) {
	*v = t = (ComponentExtension*) malloc( sizeof(ComponentExtension) );
	if ( !t ) return -1;
	*t = *k;
	}
	t->syntax = (Syntax*)NULL;
	t->comp_desc = malloc( sizeof( ComponentDesc ) );
	if ( !t->comp_desc ) {
		free ( t );
		return -1;
	}
	t->comp_desc->cd_gser_decoder = (gser_decoder_func*)GDecComponentExtension ;
	t->comp_desc->cd_ber_decoder = (ber_decoder_func*)BDecComponentExtension ;
	t->comp_desc->cd_free = (comp_free_func*)FreeComponentExtension ;
	t->comp_desc->cd_extract_i = (extract_component_from_id_func*)ExtractingComponentExtension;
	t->comp_desc->cd_type = ASN_COMPOSITE;
	t->comp_desc->cd_type_id = COMPOSITE_ASN1_TYPE;
	t->comp_desc->cd_all_match = (allcomponent_matching_func*)MatchingComponentExtension;
	return LDAP_SUCCESS;
}  /* GDecExtension*/

void FreeComponentExtension(ComponentExtension *v)
{

	if(v == NULL)
		return;
	FreeComponentOid((&v->extnID));
	free ((v->extnID).comp_desc);

	FreeComponentOcts((&v->extnValue));
	free ((v->extnValue).comp_desc);

}  /* FreeExtension */


int
MatchingComponentAttributeTypeAndValue ( char* oid, ComponentSyntaxInfo* csi_attr, ComponentSyntaxInfo* csi_assert ) {
	int rc;
	MatchingRule* mr;

	if ( oid ) {
		mr = retrieve_matching_rule( oid, csi_attr->csi_comp_desc->cd_type_id);
		if ( mr ) return component_value_match( mr, csi_attr, csi_assert );
	}

	rc = 1;
	rc =	MatchingComponentAttributeType ( oid, (ComponentSyntaxInfo*)&((ComponentAttributeTypeAndValue*)csi_attr)->type, (ComponentSyntaxInfo*)&((ComponentAttributeTypeAndValue*)csi_assert)->type );
	if ( rc != LDAP_COMPARE_TRUE )
		return rc;
	rc =	SetAnyTypeByComponentOid ((ComponentSyntaxInfo*)&((ComponentAttributeTypeAndValue*)csi_attr)->value, (&((ComponentAttributeTypeAndValue*)csi_attr)->type));
	rc = MatchingComponentAnyDefinedBy ( oid, (ComponentSyntaxInfo*)&((ComponentAttributeTypeAndValue*)csi_attr)->value, (ComponentSyntaxInfo*)&((ComponentAttributeTypeAndValue*)csi_assert)->value);
	if ( rc != LDAP_COMPARE_TRUE )
		return rc;
	return LDAP_COMPARE_TRUE;
}  /* BMatchingComponentAttributeTypeAndValue */

void*
ExtractingComponentAttributeTypeAndValue ( ComponentReference* cr, ComponentAttributeTypeAndValue *comp )
{

	if ( ( strncmp(comp->type.identifier.bv_val, cr->cr_curr->ci_val.ci_identifier.bv_val,cr->cr_curr->ci_val.ci_identifier.bv_len) == 0 ) || ( strncmp(comp->type.id_buf, cr->cr_curr->ci_val.ci_identifier.bv_val,cr->cr_curr->ci_val.ci_identifier.bv_len) == 0 ) ) {
		if ( cr->cr_curr->ci_next == NULL )
		return &comp->type;
		else
		return NULL;
	}
	if ( ( strncmp(comp->value.identifier.bv_val, cr->cr_curr->ci_val.ci_identifier.bv_val,cr->cr_curr->ci_val.ci_identifier.bv_len) == 0 ) || ( strncmp(comp->value.id_buf, cr->cr_curr->ci_val.ci_identifier.bv_val,cr->cr_curr->ci_val.ci_identifier.bv_len) == 0 ) ) {
		if ( cr->cr_curr->ci_next == NULL )
		return &comp->value;
		else
		return NULL;
	}
	return NULL;
}  /* ExtractingComponentAttributeTypeAndValue */

int
BDecComponentAttributeTypeAndValue PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, mode),
GenBuf * b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
ComponentAttributeTypeAndValue **v _AND_
AsnLen *bytesDecoded _AND_
int mode)
{
    int seqDone = FALSE, old_mode = mode;
	AsnLen totalElmtsLen1 = 0;
	AsnLen elmtLen1;
	AsnTag tagId1;
	int mandatoryElmtCount1 = 0;
	ComponentAttributeTypeAndValue *k, *t, c_temp;


	if ( !(mode & DEC_ALLOC_MODE_1) ) {
	memset(&c_temp,0,sizeof(c_temp));
		 k = &c_temp;
	} else
		 k = t = *v;
	mode = DEC_ALLOC_MODE_2;
    tagId1 = BDecTag (b, &totalElmtsLen1 );

    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, OID_TAG_CODE))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1 );
	BDecComponentAttributeType (b, tagId1, elmtLen1, (&k->type), &totalElmtsLen1, mode);
		(&k->type)->identifier.bv_val = (&k->type)->id_buf;
		(&k->type)->identifier.bv_len = strlen("type");
		strcpy( (&k->type)->identifier.bv_val, "type");
    }
    else
        return -1;



    {
    SetAnyTypeByComponentOid ((&k->value), (&k->type));
    BDecComponentAnyDefinedBy (b, (&k->value), &totalElmtsLen1, mode );
		(&k->value)->identifier.bv_val = (&k->value)->id_buf;
		(&k->value)->identifier.bv_len = strlen("value");
		strcpy( (&k->value)->identifier.bv_val, "value");
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1 );
        else if (totalElmtsLen1 != elmtLen0)
        return -1;

    }


    if (!seqDone)
        return -1;

	if( !(old_mode & DEC_ALLOC_MODE_1) ) {
	*v = t = (ComponentAttributeTypeAndValue*) malloc( sizeof(ComponentAttributeTypeAndValue) );
	if ( !t ) return -1;
	*t = *k;
	}
	t->syntax = (Syntax*)NULL;
	t->comp_desc = malloc( sizeof( ComponentDesc ) );
	if ( !t->comp_desc ) {
		free ( t );
		return -1;
	}
	t->comp_desc->cd_gser_decoder = (gser_decoder_func*)GDecComponentAttributeTypeAndValue ;
	t->comp_desc->cd_ber_decoder = (ber_decoder_func*)BDecComponentAttributeTypeAndValue ;
	t->comp_desc->cd_free = (comp_free_func*)FreeComponentAttributeTypeAndValue ;
	t->comp_desc->cd_extract_i = (extract_component_from_id_func*)ExtractingComponentAttributeTypeAndValue;
	t->comp_desc->cd_type = ASN_COMPOSITE;
	t->comp_desc->cd_type_id = COMPOSITE_ASN1_TYPE;
	t->comp_desc->cd_all_match = (allcomponent_matching_func*)MatchingComponentAttributeTypeAndValue;
    (*bytesDecoded) += totalElmtsLen1;
	return LDAP_SUCCESS;
}  /* BDecAttributeTypeAndValue*/

int
GDecComponentAttributeTypeAndValue PARAMS ((b, v, bytesDecoded, mode),
GenBuf * b _AND_
ComponentAttributeTypeAndValue **v _AND_
AsnLen *bytesDecoded _AND_
int mode)
{
	char* peek_head,*peek_head2;
	int i, strLen,strLen2, rc, old_mode = mode;
	ComponentAttributeTypeAndValue *k,*t, c_temp;


	if ( !(mode & DEC_ALLOC_MODE_1) ) {
	memset(&c_temp,0,sizeof(c_temp));
		 k = &c_temp;
	} else
		 k = t = *v;
	mode = DEC_ALLOC_MODE_2;
	*bytesDecoded = 0;
	if( !(strLen = LocateNextGSERToken(b,&peek_head,GSER_NO_COPY)) ){
		Asn1Error("Error during Reading , in encoded data");
		return LDAP_PROTOCOL_ERROR;
	}
	if(*peek_head != '{'){
		Asn1Error("Missing { in encoded data");
		return LDAP_PROTOCOL_ERROR;
	}
	if( !(strLen = LocateNextGSERToken(b,&peek_head,GSER_NO_COPY)) ){
	  Asn1Error("Error during Reading identifier");
		return LDAP_PROTOCOL_ERROR;
	}
	GDecComponentAttributeType (b, (&k->type), bytesDecoded, mode);
	(&k->type)->identifier.bv_val = peek_head;
	(&k->type)->identifier.bv_len = strLen;
	if( !(strLen = LocateNextGSERToken(b,&peek_head,GSER_NO_COPY)) ){
		Asn1Error("Error during Reading { ");
		return LDAP_PROTOCOL_ERROR;
	}
	if(*peek_head != ','){
		Asn1Error("Missing , in encoding");
		return LDAP_PROTOCOL_ERROR;
	}
	if( !(strLen = LocateNextGSERToken(b,&peek_head,GSER_NO_COPY)) ){
	  Asn1Error("Error during Reading identifier");
		return LDAP_PROTOCOL_ERROR;
	}
    SetAnyTypeByComponentOid ((&k->value), (&k->type));
    GDecComponentAnyDefinedBy (b, (&k->value), bytesDecoded, mode );
	(&k->value)->identifier.bv_val = peek_head;
	(&k->value)->identifier.bv_len = strLen;
	if( !(strLen = LocateNextGSERToken(b,&peek_head,GSER_NO_COPY)) ) {
		Asn1Error("Error during Reading } in encoding");
		return LDAP_PROTOCOL_ERROR;
	}
	if(*peek_head != '}'){
		Asn1Error("Missing } in encoding");
		return LDAP_PROTOCOL_ERROR;
	}
	if( !(old_mode & DEC_ALLOC_MODE_1) ) {
	*v = t = (ComponentAttributeTypeAndValue*) malloc( sizeof(ComponentAttributeTypeAndValue) );
	if ( !t ) return -1;
	*t = *k;
	}
	t->syntax = (Syntax*)NULL;
	t->comp_desc = malloc( sizeof( ComponentDesc ) );
	if ( !t->comp_desc ) {
		free ( t );
		return -1;
	}
	t->comp_desc->cd_gser_decoder = (gser_decoder_func*)GDecComponentAttributeTypeAndValue ;
	t->comp_desc->cd_ber_decoder = (ber_decoder_func*)BDecComponentAttributeTypeAndValue ;
	t->comp_desc->cd_free = (comp_free_func*)FreeComponentAttributeTypeAndValue ;
	t->comp_desc->cd_extract_i = (extract_component_from_id_func*)ExtractingComponentAttributeTypeAndValue;
	t->comp_desc->cd_type = ASN_COMPOSITE;
	t->comp_desc->cd_type_id = COMPOSITE_ASN1_TYPE;
	t->comp_desc->cd_all_match = (allcomponent_matching_func*)MatchingComponentAttributeTypeAndValue;
	return LDAP_SUCCESS;
}  /* GDecAttributeTypeAndValue*/

void FreeComponentAttributeTypeAndValue(ComponentAttributeTypeAndValue *v)
{

	if(v == NULL)
		return;
	FreeComponentAttributeType((&v->type));
	free ((v->type).comp_desc);

	FreeComponentAnyDefinedBy((&v->value));
	free ((v->value).comp_desc);

}  /* FreeAttributeTypeAndValue */


int
MatchingComponentValidity ( char* oid, ComponentSyntaxInfo* csi_attr, ComponentSyntaxInfo* csi_assert ) {
	int rc;
	MatchingRule* mr;

	if ( oid ) {
		mr = retrieve_matching_rule( oid, csi_attr->csi_comp_desc->cd_type_id);
		if ( mr ) return component_value_match( mr, csi_attr, csi_assert );
	}

	rc = 1;
	rc =	MatchingComponentTime ( oid, (ComponentSyntaxInfo*)((ComponentValidity*)csi_attr)->notBefore, (ComponentSyntaxInfo*)((ComponentValidity*)csi_assert)->notBefore );
	if ( rc != LDAP_COMPARE_TRUE )
		return rc;
	rc =	MatchingComponentTime ( oid, (ComponentSyntaxInfo*)((ComponentValidity*)csi_attr)->notAfter, (ComponentSyntaxInfo*)((ComponentValidity*)csi_assert)->notAfter );
	if ( rc != LDAP_COMPARE_TRUE )
		return rc;
	return LDAP_COMPARE_TRUE;
}  /* BMatchingComponentValidity */

void*
ExtractingComponentValidity ( ComponentReference* cr, ComponentValidity *comp )
{

	if ( ( strncmp(comp->notBefore->identifier.bv_val, cr->cr_curr->ci_val.ci_identifier.bv_val,cr->cr_curr->ci_val.ci_identifier.bv_len) == 0 ) || ( strncmp(comp->notBefore->id_buf, cr->cr_curr->ci_val.ci_identifier.bv_val,cr->cr_curr->ci_val.ci_identifier.bv_len) == 0 ) ) {
		if ( cr->cr_curr->ci_next == NULL )
			return comp->notBefore;
		else {
			cr->cr_curr = cr->cr_curr->ci_next;
			return 	ExtractingComponentTime ( cr, comp->notBefore );
		}
	}
	if ( ( strncmp(comp->notAfter->identifier.bv_val, cr->cr_curr->ci_val.ci_identifier.bv_val,cr->cr_curr->ci_val.ci_identifier.bv_len) == 0 ) || ( strncmp(comp->notAfter->id_buf, cr->cr_curr->ci_val.ci_identifier.bv_val,cr->cr_curr->ci_val.ci_identifier.bv_len) == 0 ) ) {
		if ( cr->cr_curr->ci_next == NULL )
			return comp->notAfter;
		else {
			cr->cr_curr = cr->cr_curr->ci_next;
			return 	ExtractingComponentTime ( cr, comp->notAfter );
		}
	}
	return NULL;
}  /* ExtractingComponentValidity */

int
BDecComponentValidity PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, mode),
GenBuf * b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
ComponentValidity **v _AND_
AsnLen *bytesDecoded _AND_
int mode)
{
    int seqDone = FALSE, old_mode = mode;
	AsnLen totalElmtsLen1 = 0;
	AsnLen elmtLen1;
	AsnTag tagId1;
	int mandatoryElmtCount1 = 0;
	AsnLen totalElmtsLen2 = 0;
	AsnLen elmtLen2;
	AsnTag tagId2;
	ComponentValidity *k, *t, c_temp;


	if ( !(mode & DEC_ALLOC_MODE_1) ) {
	memset(&c_temp,0,sizeof(c_temp));
		 k = &c_temp;
	} else
		 k = t = *v;
	mode = DEC_ALLOC_MODE_2;
    tagId1 = BDecTag (b, &totalElmtsLen1 );

    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, UTCTIME_TAG_CODE)) ||
(tagId1 == MAKE_TAG_ID (UNIV, CONS, UTCTIME_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, GENERALIZEDTIME_TAG_CODE))||
    (tagId1 == MAKE_TAG_ID (UNIV, CONS, GENERALIZEDTIME_TAG_CODE))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1 );
	BDecComponentTime (b, tagId1, elmtLen1, (&k->notBefore), &totalElmtsLen1, mode);
		(k->notBefore)->identifier.bv_val = (k->notBefore)->id_buf;
		(k->notBefore)->identifier.bv_len = strlen("notBefore");
		strcpy( (k->notBefore)->identifier.bv_val, "notBefore");
    tagId1 = BDecTag (b, &totalElmtsLen1);
    }
    else
        return -1;



    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, UTCTIME_TAG_CODE)) ||
(tagId1 == MAKE_TAG_ID (UNIV, CONS, UTCTIME_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, GENERALIZEDTIME_TAG_CODE))||
    (tagId1 == MAKE_TAG_ID (UNIV, CONS, GENERALIZEDTIME_TAG_CODE))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1 );
	BDecComponentTime (b, tagId1, elmtLen1, (&k->notAfter), &totalElmtsLen1, mode);
		(k->notAfter)->identifier.bv_val = (k->notAfter)->id_buf;
		(k->notAfter)->identifier.bv_len = strlen("notAfter");
		strcpy( (k->notAfter)->identifier.bv_val, "notAfter");
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1 );
        else if (totalElmtsLen1 != elmtLen0)
        return -1;

    }
    else
        return -1;



    if (!seqDone)
        return -1;

	if( !(old_mode & DEC_ALLOC_MODE_1) ) {
	*v = t = (ComponentValidity*) malloc( sizeof(ComponentValidity) );
	if ( !t ) return -1;
	*t = *k;
	}
	t->syntax = (Syntax*)NULL;
	t->comp_desc = malloc( sizeof( ComponentDesc ) );
	if ( !t->comp_desc ) {
		free ( t );
		return -1;
	}
	t->comp_desc->cd_gser_decoder = (gser_decoder_func*)GDecComponentValidity ;
	t->comp_desc->cd_ber_decoder = (ber_decoder_func*)BDecComponentValidity ;
	t->comp_desc->cd_free = (comp_free_func*)FreeComponentValidity ;
	t->comp_desc->cd_extract_i = (extract_component_from_id_func*)ExtractingComponentValidity;
	t->comp_desc->cd_type = ASN_COMPOSITE;
	t->comp_desc->cd_type_id = COMPOSITE_ASN1_TYPE;
	t->comp_desc->cd_all_match = (allcomponent_matching_func*)MatchingComponentValidity;
    (*bytesDecoded) += totalElmtsLen1;
	return LDAP_SUCCESS;
}  /* BDecValidity*/

int
GDecComponentValidity PARAMS ((b, v, bytesDecoded, mode),
GenBuf * b _AND_
ComponentValidity **v _AND_
AsnLen *bytesDecoded _AND_
int mode)
{
	char* peek_head,*peek_head2;
	int i, strLen,strLen2, rc, old_mode = mode;
	ComponentValidity *k,*t, c_temp;


	if ( !(mode & DEC_ALLOC_MODE_1) ) {
	memset(&c_temp,0,sizeof(c_temp));
		 k = &c_temp;
	} else
		 k = t = *v;
	mode = DEC_ALLOC_MODE_2;
	*bytesDecoded = 0;
	if( !(strLen = LocateNextGSERToken(b,&peek_head,GSER_NO_COPY)) ){
		Asn1Error("Error during Reading , in encoded data");
		return LDAP_PROTOCOL_ERROR;
	}
	if(*peek_head != '{'){
		Asn1Error("Missing { in encoded data");
		return LDAP_PROTOCOL_ERROR;
	}
	if( !(strLen = LocateNextGSERToken(b,&peek_head,GSER_NO_COPY)) ){
	  Asn1Error("Error during Reading identifier");
		return LDAP_PROTOCOL_ERROR;
	}
	GDecComponentTime (b, (&k->notBefore), bytesDecoded, mode);
	( k->notBefore)->identifier.bv_val = peek_head;
	( k->notBefore)->identifier.bv_len = strLen;
	if( !(strLen = LocateNextGSERToken(b,&peek_head,GSER_NO_COPY)) ){
		Asn1Error("Error during Reading { ");
		return LDAP_PROTOCOL_ERROR;
	}
	if(*peek_head != ','){
		Asn1Error("Missing , in encoding");
		return LDAP_PROTOCOL_ERROR;
	}
	if( !(strLen = LocateNextGSERToken(b,&peek_head,GSER_NO_COPY)) ){
	  Asn1Error("Error during Reading identifier");
		return LDAP_PROTOCOL_ERROR;
	}
	GDecComponentTime (b, (&k->notAfter), bytesDecoded, mode);
	( k->notAfter)->identifier.bv_val = peek_head;
	( k->notAfter)->identifier.bv_len = strLen;
	if( !(strLen = LocateNextGSERToken(b,&peek_head,GSER_NO_COPY)) ) {
		Asn1Error("Error during Reading } in encoding");
		return LDAP_PROTOCOL_ERROR;
	}
	if(*peek_head != '}'){
		Asn1Error("Missing } in encoding");
		return LDAP_PROTOCOL_ERROR;
	}
	if( !(old_mode & DEC_ALLOC_MODE_1) ) {
	*v = t = (ComponentValidity*) malloc( sizeof(ComponentValidity) );
	if ( !t ) return -1;
	*t = *k;
	}
	t->syntax = (Syntax*)NULL;
	t->comp_desc = malloc( sizeof( ComponentDesc ) );
	if ( !t->comp_desc ) {
		free ( t );
		return -1;
	}
	t->comp_desc->cd_gser_decoder = (gser_decoder_func*)GDecComponentValidity ;
	t->comp_desc->cd_ber_decoder = (ber_decoder_func*)BDecComponentValidity ;
	t->comp_desc->cd_free = (comp_free_func*)FreeComponentValidity ;
	t->comp_desc->cd_extract_i = (extract_component_from_id_func*)ExtractingComponentValidity;
	t->comp_desc->cd_type = ASN_COMPOSITE;
	t->comp_desc->cd_type_id = COMPOSITE_ASN1_TYPE;
	t->comp_desc->cd_all_match = (allcomponent_matching_func*)MatchingComponentValidity;
	return LDAP_SUCCESS;
}  /* GDecValidity*/

void FreeComponentValidity(ComponentValidity *v)
{

	if(v == NULL)
		return;
	FreeComponentTime((v->notBefore));
	free ((v->notBefore)->comp_desc);
	free ((v->notBefore));

	FreeComponentTime((v->notAfter));
	free ((v->notAfter)->comp_desc);
	free ((v->notAfter));

}  /* FreeValidity */


int
MatchingComponentSubjectPublicKeyInfo ( char* oid, ComponentSyntaxInfo* csi_attr, ComponentSyntaxInfo* csi_assert ) {
	int rc;
	MatchingRule* mr;

	if ( oid ) {
		mr = retrieve_matching_rule( oid, csi_attr->csi_comp_desc->cd_type_id);
		if ( mr ) return component_value_match( mr, csi_attr, csi_assert );
	}

	rc = 1;
	rc =	MatchingComponentAlgorithmIdentifier ( oid, (ComponentSyntaxInfo*)((ComponentSubjectPublicKeyInfo*)csi_attr)->algorithm, (ComponentSyntaxInfo*)((ComponentSubjectPublicKeyInfo*)csi_assert)->algorithm );
	if ( rc != LDAP_COMPARE_TRUE )
		return rc;
	rc =	MatchingComponentBits ( oid, (ComponentSyntaxInfo*)&((ComponentSubjectPublicKeyInfo*)csi_attr)->subjectPublicKey, (ComponentSyntaxInfo*)&((ComponentSubjectPublicKeyInfo*)csi_assert)->subjectPublicKey );
	if ( rc != LDAP_COMPARE_TRUE )
		return rc;
	return LDAP_COMPARE_TRUE;
}  /* BMatchingComponentSubjectPublicKeyInfo */

void*
ExtractingComponentSubjectPublicKeyInfo ( ComponentReference* cr, ComponentSubjectPublicKeyInfo *comp )
{

	if ( ( strncmp(comp->algorithm->identifier.bv_val, cr->cr_curr->ci_val.ci_identifier.bv_val,cr->cr_curr->ci_val.ci_identifier.bv_len) == 0 ) || ( strncmp(comp->algorithm->id_buf, cr->cr_curr->ci_val.ci_identifier.bv_val,cr->cr_curr->ci_val.ci_identifier.bv_len) == 0 ) ) {
		if ( cr->cr_curr->ci_next == NULL )
			return comp->algorithm;
		else {
			cr->cr_curr = cr->cr_curr->ci_next;
			return 	ExtractingComponentAlgorithmIdentifier ( cr, comp->algorithm );
		}
	}
	if ( ( strncmp(comp->subjectPublicKey.identifier.bv_val, cr->cr_curr->ci_val.ci_identifier.bv_val,cr->cr_curr->ci_val.ci_identifier.bv_len) == 0 ) || ( strncmp(comp->subjectPublicKey.id_buf, cr->cr_curr->ci_val.ci_identifier.bv_val,cr->cr_curr->ci_val.ci_identifier.bv_len) == 0 ) ) {
		if ( cr->cr_curr->ci_next == NULL )
		return &comp->subjectPublicKey;
		else
		return NULL;
	}
	return NULL;
}  /* ExtractingComponentSubjectPublicKeyInfo */

int
BDecComponentSubjectPublicKeyInfo PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, mode),
GenBuf * b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
ComponentSubjectPublicKeyInfo **v _AND_
AsnLen *bytesDecoded _AND_
int mode)
{
    int seqDone = FALSE, old_mode = mode;
	AsnLen totalElmtsLen1 = 0;
	AsnLen elmtLen1;
	AsnTag tagId1;
	int mandatoryElmtCount1 = 0;
	ComponentSubjectPublicKeyInfo *k, *t, c_temp;


	if ( !(mode & DEC_ALLOC_MODE_1) ) {
	memset(&c_temp,0,sizeof(c_temp));
		 k = &c_temp;
	} else
		 k = t = *v;
	mode = DEC_ALLOC_MODE_2;
    tagId1 = BDecTag (b, &totalElmtsLen1 );

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1 );
	BDecComponentAlgorithmIdentifier (b, tagId1, elmtLen1, (&k->algorithm), &totalElmtsLen1, mode);
		(k->algorithm)->identifier.bv_val = (k->algorithm)->id_buf;
		(k->algorithm)->identifier.bv_len = strlen("algorithm");
		strcpy( (k->algorithm)->identifier.bv_val, "algorithm");
    tagId1 = BDecTag (b, &totalElmtsLen1);
    }
    else
        return -1;



    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, BITSTRING_TAG_CODE)) ||
(tagId1 == MAKE_TAG_ID (UNIV, CONS, BITSTRING_TAG_CODE))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1 );
	BDecComponentBits (b, tagId1, elmtLen1, (&k->subjectPublicKey), &totalElmtsLen1, mode);
		(&k->subjectPublicKey)->identifier.bv_val = (&k->subjectPublicKey)->id_buf;
		(&k->subjectPublicKey)->identifier.bv_len = strlen("subjectPublicKey");
		strcpy( (&k->subjectPublicKey)->identifier.bv_val, "subjectPublicKey");
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1 );
        else if (totalElmtsLen1 != elmtLen0)
        return -1;

    }
    else
        return -1;



    if (!seqDone)
        return -1;

	if( !(old_mode & DEC_ALLOC_MODE_1) ) {
	*v = t = (ComponentSubjectPublicKeyInfo*) malloc( sizeof(ComponentSubjectPublicKeyInfo) );
	if ( !t ) return -1;
	*t = *k;
	}
	t->syntax = (Syntax*)NULL;
	t->comp_desc = malloc( sizeof( ComponentDesc ) );
	if ( !t->comp_desc ) {
		free ( t );
		return -1;
	}
	t->comp_desc->cd_gser_decoder = (gser_decoder_func*)GDecComponentSubjectPublicKeyInfo ;
	t->comp_desc->cd_ber_decoder = (ber_decoder_func*)BDecComponentSubjectPublicKeyInfo ;
	t->comp_desc->cd_free = (comp_free_func*)FreeComponentSubjectPublicKeyInfo ;
	t->comp_desc->cd_extract_i = (extract_component_from_id_func*)ExtractingComponentSubjectPublicKeyInfo;
	t->comp_desc->cd_type = ASN_COMPOSITE;
	t->comp_desc->cd_type_id = COMPOSITE_ASN1_TYPE;
	t->comp_desc->cd_all_match = (allcomponent_matching_func*)MatchingComponentSubjectPublicKeyInfo;
    (*bytesDecoded) += totalElmtsLen1;
	return LDAP_SUCCESS;
}  /* BDecSubjectPublicKeyInfo*/

int
GDecComponentSubjectPublicKeyInfo PARAMS ((b, v, bytesDecoded, mode),
GenBuf * b _AND_
ComponentSubjectPublicKeyInfo **v _AND_
AsnLen *bytesDecoded _AND_
int mode)
{
	char* peek_head,*peek_head2;
	int i, strLen,strLen2, rc, old_mode = mode;
	ComponentSubjectPublicKeyInfo *k,*t, c_temp;


	if ( !(mode & DEC_ALLOC_MODE_1) ) {
	memset(&c_temp,0,sizeof(c_temp));
		 k = &c_temp;
	} else
		 k = t = *v;
	mode = DEC_ALLOC_MODE_2;
	*bytesDecoded = 0;
	if( !(strLen = LocateNextGSERToken(b,&peek_head,GSER_NO_COPY)) ){
		Asn1Error("Error during Reading , in encoded data");
		return LDAP_PROTOCOL_ERROR;
	}
	if(*peek_head != '{'){
		Asn1Error("Missing { in encoded data");
		return LDAP_PROTOCOL_ERROR;
	}
	if( !(strLen = LocateNextGSERToken(b,&peek_head,GSER_NO_COPY)) ){
	  Asn1Error("Error during Reading identifier");
		return LDAP_PROTOCOL_ERROR;
	}
	GDecComponentAlgorithmIdentifier (b, (&k->algorithm), bytesDecoded, mode);
	( k->algorithm)->identifier.bv_val = peek_head;
	( k->algorithm)->identifier.bv_len = strLen;
	if( !(strLen = LocateNextGSERToken(b,&peek_head,GSER_NO_COPY)) ){
		Asn1Error("Error during Reading { ");
		return LDAP_PROTOCOL_ERROR;
	}
	if(*peek_head != ','){
		Asn1Error("Missing , in encoding");
		return LDAP_PROTOCOL_ERROR;
	}
	if( !(strLen = LocateNextGSERToken(b,&peek_head,GSER_NO_COPY)) ){
	  Asn1Error("Error during Reading identifier");
		return LDAP_PROTOCOL_ERROR;
	}
	GDecComponentBits (b, (&k->subjectPublicKey), bytesDecoded, mode);
	(&k->subjectPublicKey)->identifier.bv_val = peek_head;
	(&k->subjectPublicKey)->identifier.bv_len = strLen;
	if( !(strLen = LocateNextGSERToken(b,&peek_head,GSER_NO_COPY)) ) {
		Asn1Error("Error during Reading } in encoding");
		return LDAP_PROTOCOL_ERROR;
	}
	if(*peek_head != '}'){
		Asn1Error("Missing } in encoding");
		return LDAP_PROTOCOL_ERROR;
	}
	if( !(old_mode & DEC_ALLOC_MODE_1) ) {
	*v = t = (ComponentSubjectPublicKeyInfo*) malloc( sizeof(ComponentSubjectPublicKeyInfo) );
	if ( !t ) return -1;
	*t = *k;
	}
	t->syntax = (Syntax*)NULL;
	t->comp_desc = malloc( sizeof( ComponentDesc ) );
	if ( !t->comp_desc ) {
		free ( t );
		return -1;
	}
	t->comp_desc->cd_gser_decoder = (gser_decoder_func*)GDecComponentSubjectPublicKeyInfo ;
	t->comp_desc->cd_ber_decoder = (ber_decoder_func*)BDecComponentSubjectPublicKeyInfo ;
	t->comp_desc->cd_free = (comp_free_func*)FreeComponentSubjectPublicKeyInfo ;
	t->comp_desc->cd_extract_i = (extract_component_from_id_func*)ExtractingComponentSubjectPublicKeyInfo;
	t->comp_desc->cd_type = ASN_COMPOSITE;
	t->comp_desc->cd_type_id = COMPOSITE_ASN1_TYPE;
	t->comp_desc->cd_all_match = (allcomponent_matching_func*)MatchingComponentSubjectPublicKeyInfo;
	return LDAP_SUCCESS;
}  /* GDecSubjectPublicKeyInfo*/

void FreeComponentSubjectPublicKeyInfo(ComponentSubjectPublicKeyInfo *v)
{

	if(v == NULL)
		return;
	FreeComponentAlgorithmIdentifier((v->algorithm));
	free ((v->algorithm)->comp_desc);
	free ((v->algorithm));

	FreeComponentBits((&v->subjectPublicKey));
	free ((v->subjectPublicKey).comp_desc);

}  /* FreeSubjectPublicKeyInfo */


int
MatchingComponentExtensions ( char* oid, ComponentSyntaxInfo* csi_attr, ComponentSyntaxInfo* csi_assert ) {
	int rc;
	MatchingRule* mr;
	void* component1, *component2;
	AsnList *v1, *v2, t_list;


	if ( oid ) {
		mr = retrieve_matching_rule( oid, csi_attr->csi_comp_desc->cd_type_id);
		if ( mr ) return component_value_match( mr, csi_attr, csi_assert );
	}

	v1 = &((ComponentExtensions*)csi_attr)->comp_list;
	v2 = &((ComponentExtensions*)csi_assert)->comp_list;
	FOR_EACH_LIST_PAIR_ELMT(component1, component2, v1, v2)
	{
		if( MatchingComponentExtension(oid, (ComponentSyntaxInfo*)component1, (ComponentSyntaxInfo*)component2) == LDAP_COMPARE_FALSE) {
			return LDAP_COMPARE_FALSE;
		}
	} /* end of for */

	if( (!component1 && component2) || (component1 && !component2))
		return LDAP_COMPARE_FALSE;
	else
		return LDAP_COMPARE_TRUE;
}  /* BMatchingComponentExtensionsContent */

void*
ExtractingComponentExtensions ( ComponentReference* cr, ComponentExtensions *comp )
{
	int count = 0;
	int total;
	AsnList *v = &comp->comp_list;
	ComponentInt *k;
	ComponentExtension *component;


	switch ( cr->cr_curr->ci_type ) {
	case LDAP_COMPREF_FROM_BEGINNING :
		count = cr->cr_curr->ci_val.ci_from_beginning;
		FOR_EACH_LIST_ELMT( component , v ) {
			if( --count == 0 ) {
				if( cr->cr_curr->ci_next == NULL )
					return component;
				else {
					cr->cr_curr = cr->cr_curr->ci_next;
					return
	ExtractingComponentExtension ( cr, component );
				}
			}
		}
		break;
	case LDAP_COMPREF_FROM_END :
		total = AsnListCount ( v );
		count = cr->cr_curr->ci_val.ci_from_end;
		count = total + count +1;
		FOR_EACH_LIST_ELMT ( component, v ) {
			if( --count == 0 ) {
				if( cr->cr_curr->ci_next == NULL ) 
					return component;
				else {
					cr->cr_curr = cr->cr_curr->ci_next;
					return
	ExtractingComponentExtension ( cr, component );
				}
			}
		}
		break;
	case LDAP_COMPREF_ALL :
		return comp;
		k = (ComponentInt*)malloc(sizeof(ComponentInt));
		k->comp_desc = malloc( sizeof( ComponentDesc ) );
		k->comp_desc->cd_tag = NULL;
		k->comp_desc->cd_gser_decoder = (gser_decoder_func*)GDecComponentInt;
		k->comp_desc->cd_ber_decoder = (ber_decoder_func*)BDecComponentInt;
		k->comp_desc->cd_extract_i = (extract_component_from_id_func*)NULL;
		k->comp_desc->cd_type = ASN_BASIC;
		k->comp_desc->cd_type_id = BASICTYPE_INTEGER;
		k->comp_desc->cd_all_match = (allcomponent_matching_func*)MatchingComponentInt;
		k->value = AsnListCount(v);
		return k;
	default :
		return NULL;
	}
}  /* ExtractingComponentExtensions */

int
BDecComponentExtensions PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, mode),
GenBuf * b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
ComponentExtensions **v _AND_
AsnLen *bytesDecoded _AND_
int mode)
{
    int seqDone = FALSE, old_mode = mode;
	AsnLen totalElmtsLen1 = 0;
	AsnLen elmtLen1;
	AsnTag tagId1;
	int mandatoryElmtCount1 = 0;
	ComponentExtensions *k, *t, c_temp;


	if ( !(mode & DEC_ALLOC_MODE_1) ) {
	memset(&c_temp,0,sizeof(c_temp));
		 k = &c_temp;
	} else
		 k = t = *v;
	mode = DEC_ALLOC_MODE_2;
	AsnListInit(&k->comp_list,sizeof(ComponentExtension));
    for (totalElmtsLen1 = 0; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
    {
        ComponentExtension **tmpVar;
    tagId1 = BDecTag (b, &totalElmtsLen1 );

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1 )
        break; /* got EOC so can exit this SET OF/SEQ OF's for loop*/
    }
    if ((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1 );
    tmpVar = (ComponentExtension**) AsnListAppend (&k->comp_list);
	BDecComponentExtension (b, tagId1, elmtLen1, tmpVar, &totalElmtsLen1, mode);
    }  /* end of tag check if */
    else  /* wrong tag */
    {
         Asn1Error ("Unexpected Tag\n");
         return -1;
    }
    } /* end of for */

	if( !(old_mode & DEC_ALLOC_MODE_1) ) {
	*v = t = (ComponentExtensions*) malloc( sizeof(ComponentExtensions) );
	if ( !t ) return -1;
	*t = *k;
	}
	t->syntax = (Syntax*)NULL;
	t->comp_desc = malloc( sizeof( ComponentDesc ) );
	if ( !t->comp_desc ) {
		free ( t );
		return -1;
	}
	t->comp_desc->cd_gser_decoder = (gser_decoder_func*)GDecComponentExtensions ;
	t->comp_desc->cd_ber_decoder = (ber_decoder_func*)BDecComponentExtensions ;
	t->comp_desc->cd_free = (comp_free_func*)FreeComponentExtensions ;
	t->comp_desc->cd_extract_i = (extract_component_from_id_func*)ExtractingComponentExtensions;
	t->comp_desc->cd_type = ASN_COMPOSITE;
	t->comp_desc->cd_type_id = COMPOSITE_ASN1_TYPE;
	t->comp_desc->cd_all_match = (allcomponent_matching_func*)MatchingComponentExtensions;
    (*bytesDecoded) += totalElmtsLen1;
	return LDAP_SUCCESS;
}  /* BDecExtensionsContent */

int
GDecComponentExtensions PARAMS ((b, v, bytesDecoded, mode),
GenBuf * b _AND_
ComponentExtensions **v _AND_
AsnLen *bytesDecoded _AND_
int mode)
{
	char* peek_head,*peek_head2;
	int i, strLen,strLen2, rc, old_mode = mode;
	ComponentExtensions *k,*t, c_temp;


	int ElmtsLen1;
	if ( !(mode & DEC_ALLOC_MODE_1) ) {
	memset(&c_temp,0,sizeof(c_temp));
		 k = &c_temp;
	} else
		 k = t = *v;
	mode = DEC_ALLOC_MODE_2;
	AsnListInit( &k->comp_list, sizeof( ComponentExtension ) );
	bytesDecoded = 0;
	if( !(strLen = LocateNextGSERToken(b, &peek_head, GSER_PEEK)) ){
		Asn1Error("Error during Reading { in encoding");
		return LDAP_PROTOCOL_ERROR;
	}
	if(*peek_head != '{'){
		Asn1Error("Missing { in encoded data");
		return LDAP_PROTOCOL_ERROR;
	}

	for (ElmtsLen1 = 0; ElmtsLen1 >= INDEFINITE_LEN; ElmtsLen1++)
	{
		ComponentExtension **tmpVar;
		if( !(strLen = LocateNextGSERToken(b, &peek_head, GSER_NO_COPY)) ){
			Asn1Error("Error during Reading{ in encoding");
			return LDAP_PROTOCOL_ERROR;
		}
		if(*peek_head == '}') break;
		if( !(*peek_head == '{' || *peek_head ==',') ) {
			return LDAP_PROTOCOL_ERROR;
		}
		tmpVar = (ComponentExtension**) AsnListAppend (&k->comp_list);
		if ( tmpVar == NULL ) {
			Asn1Error("Error during Reading{ in encoding");
			return LDAP_PROTOCOL_ERROR;
		}
	GDecComponentExtension (b, tmpVar, bytesDecoded, mode);
	} /* end of for */

	if( !(old_mode & DEC_ALLOC_MODE_1) ) {
	*v = t = (ComponentExtensions*) malloc( sizeof(ComponentExtensions) );
	if ( !t ) return -1;
	*t = *k;
	}
	t->syntax = (Syntax*)NULL;
	t->comp_desc = malloc( sizeof( ComponentDesc ) );
	if ( !t->comp_desc ) {
		free ( t );
		return -1;
	}
	t->comp_desc->cd_gser_decoder = (gser_decoder_func*)GDecComponentExtensions ;
	t->comp_desc->cd_ber_decoder = (ber_decoder_func*)BDecComponentExtensions ;
	t->comp_desc->cd_free = (comp_free_func*)FreeComponentExtensions ;
	t->comp_desc->cd_extract_i = (extract_component_from_id_func*)ExtractingComponentExtensions;
	t->comp_desc->cd_type = ASN_COMPOSITE;
	t->comp_desc->cd_type_id = COMPOSITE_ASN1_TYPE;
	t->comp_desc->cd_all_match = (allcomponent_matching_func*)MatchingComponentExtensions;
	return LDAP_SUCCESS;
}  /* GDecExtensionsContent */

void FreeComponentExtensions(ComponentExtensions *v)
{

	AsnListNode *l;
	AsnListNode *tmp;
	if(v == NULL)
		return;
	for (l = FIRST_LIST_NODE (&v->comp_list); l != NULL; )
	{
		FreeComponentExtension ((l->data));
		tmp = l->next;
		free (((ComponentSyntaxInfo*)l->data)->csi_comp_desc);
		free (l->data);
		free (l);
		l = tmp;
	}
}  /* FreeExtensions */


int
MatchingComponentRelativeDistinguishedName ( char* oid, ComponentSyntaxInfo* csi_attr, ComponentSyntaxInfo* csi_assert ) {
	int rc;
	MatchingRule* mr;
	void* component1, *component2;
	AsnList *v1, *v2, t_list;


	if ( oid ) {
		mr = retrieve_matching_rule( oid, csi_attr->csi_comp_desc->cd_type_id);
		if ( mr ) return component_value_match( mr, csi_attr, csi_assert );
	}

	v1 = &((ComponentRelativeDistinguishedName*)csi_attr)->comp_list;
	v2 = &((ComponentRelativeDistinguishedName*)csi_assert)->comp_list;
	AsnListInit( &t_list, 0 );
	if( AsnListCount( v1 ) != AsnListCount( v2 ) )
		return LDAP_COMPARE_FALSE;
	FOR_EACH_LIST_ELMT (component1, v1)
	{
		FOR_EACH_LIST_ELMT(component2, v2)
		{
			if( MatchingComponentAttributeTypeAndValue(oid, (ComponentSyntaxInfo*)component1,(ComponentSyntaxInfo*)component2) == LDAP_COMPARE_TRUE ) {
			AsnElmtMove( v2, &t_list );
			   break;
			}
		} /* end of inner for */
	} /* end of outer for */

	if( AsnListCount( v2 ) == 0 )
		 rc = LDAP_COMPARE_TRUE;
	else
		 rc = LDAP_COMPARE_FALSE;
	AsnListMove( &t_list, v2 );
	AsnListFirst(v1);
	AsnListFirst(v2);
	return rc;
}  /* BMatchingComponentRelativeDistinguishedNameContent */

void*
ExtractingComponentRelativeDistinguishedName ( ComponentReference* cr, ComponentRelativeDistinguishedName *comp )
{
	int count = 0;
	int total;
	AsnList *v = &comp->comp_list;
	ComponentInt *k;
	ComponentAttributeTypeAndValue *component;


	switch ( cr->cr_curr->ci_type ) {
	case LDAP_COMPREF_FROM_BEGINNING :
		count = cr->cr_curr->ci_val.ci_from_beginning;
		FOR_EACH_LIST_ELMT( component , v ) {
			if( --count == 0 ) {
				if( cr->cr_curr->ci_next == NULL )
					return component;
				else {
					cr->cr_curr = cr->cr_curr->ci_next;
					return
	ExtractingComponentAttributeTypeAndValue ( cr, component );
				}
			}
		}
		break;
	case LDAP_COMPREF_FROM_END :
		total = AsnListCount ( v );
		count = cr->cr_curr->ci_val.ci_from_end;
		count = total + count +1;
		FOR_EACH_LIST_ELMT ( component, v ) {
			if( --count == 0 ) {
				if( cr->cr_curr->ci_next == NULL )
					return component;
				else {
					cr->cr_curr = cr->cr_curr->ci_next;
					return
	ExtractingComponentAttributeTypeAndValue ( cr, component );
				}
			}
		}
		break;
	case LDAP_COMPREF_ALL :
		return comp;
		k = (ComponentInt*)malloc(sizeof(ComponentInt));
		k->comp_desc = malloc( sizeof( ComponentDesc ) );
		k->comp_desc->cd_tag = NULL;
		k->comp_desc->cd_gser_decoder = (gser_decoder_func*)GDecComponentInt;
		k->comp_desc->cd_ber_decoder = (ber_decoder_func*)BDecComponentInt;
		k->comp_desc->cd_extract_i = (extract_component_from_id_func*)NULL;
		k->comp_desc->cd_type = ASN_BASIC;
		k->comp_desc->cd_type_id = BASICTYPE_INTEGER;
		k->comp_desc->cd_all_match = (allcomponent_matching_func*)MatchingComponentInt;
		k->value = AsnListCount(v);
		return k;
	default :
		return NULL;
	}
}  /* ExtractingComponentRelativeDistinguishedName */

int
BDecComponentRelativeDistinguishedName PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, mode),
GenBuf * b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
ComponentRelativeDistinguishedName **v _AND_
AsnLen *bytesDecoded _AND_
int mode)
{
    int seqDone = FALSE, old_mode = mode;
	AsnLen totalElmtsLen1 = 0;
	AsnLen elmtLen1;
	AsnTag tagId1;
	int mandatoryElmtCount1 = 0;
	ComponentRelativeDistinguishedName *k, *t, c_temp;


	if ( !(mode & DEC_ALLOC_MODE_1) ) {
	memset(&c_temp,0,sizeof(c_temp));
		 k = &c_temp;
	} else
		 k = t = *v;
	mode = DEC_ALLOC_MODE_2;
	AsnListInit(&k->comp_list,sizeof(ComponentAttributeTypeAndValue));
    for (totalElmtsLen1 = 0; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
    {
        ComponentAttributeTypeAndValue **tmpVar;
    tagId1 = BDecTag (b, &totalElmtsLen1 );

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1 )
        break; /* got EOC so can exit this SET OF/SEQ OF's for loop*/
    }
    if ((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1 );
    tmpVar = (ComponentAttributeTypeAndValue**) AsnListAppend (&k->comp_list);
	BDecComponentAttributeTypeAndValue (b, tagId1, elmtLen1, tmpVar, &totalElmtsLen1, mode);
    }  /* end of tag check if */
    else  /* wrong tag */
    {
         Asn1Error ("Unexpected Tag\n");
         return -1;
    }
    } /* end of for */

	if( !(old_mode & DEC_ALLOC_MODE_1) ) {
	*v = t = (ComponentRelativeDistinguishedName*) malloc( sizeof(ComponentRelativeDistinguishedName) );
	if ( !t ) return -1;
	*t = *k;
	}
	t->syntax = (Syntax*)NULL;
	t->comp_desc = malloc( sizeof( ComponentDesc ) );
	if ( !t->comp_desc ) {
		free ( t );
		return -1;
	}
	t->comp_desc->cd_gser_decoder = (gser_decoder_func*)GDecComponentRelativeDistinguishedName ;
	t->comp_desc->cd_ber_decoder = (ber_decoder_func*)BDecComponentRelativeDistinguishedName ;
	t->comp_desc->cd_free = (comp_free_func*)FreeComponentRelativeDistinguishedName ;
	t->comp_desc->cd_extract_i = (extract_component_from_id_func*)ExtractingComponentRelativeDistinguishedName;
	t->comp_desc->cd_type = ASN_COMPOSITE;
	t->comp_desc->cd_type_id = COMPOSITE_ASN1_TYPE;
	t->comp_desc->cd_all_match = (allcomponent_matching_func*)MatchingComponentRelativeDistinguishedName;
    (*bytesDecoded) += totalElmtsLen1;
	return LDAP_SUCCESS;
}  /* BDecRelativeDistinguishedNameContent */

int
GDecComponentRelativeDistinguishedName PARAMS ((b, v, bytesDecoded, mode),
GenBuf * b _AND_
ComponentRelativeDistinguishedName **v _AND_
AsnLen *bytesDecoded _AND_
int mode)
{
	char* peek_head,*peek_head2;
	int i, strLen,strLen2, rc, old_mode = mode;
	ComponentRelativeDistinguishedName *k,*t, c_temp;


	int ElmtsLen1;
	if ( !(mode & DEC_ALLOC_MODE_1) ) {
	memset(&c_temp,0,sizeof(c_temp));
		 k = &c_temp;
	} else
		 k = t = *v;
	mode = DEC_ALLOC_MODE_2;
	AsnListInit( &k->comp_list, sizeof( ComponentAttributeTypeAndValue ) );
	*bytesDecoded = 0;
	if( !(strLen = LocateNextGSERToken(b, &peek_head, GSER_PEEK)) ){
		Asn1Error("Error during Reading { in encoding");
		return LDAP_PROTOCOL_ERROR;
	}
	if(*peek_head != '{'){
		Asn1Error("Missing { in encoded data");
		return LDAP_PROTOCOL_ERROR;
	}

	for (ElmtsLen1 = 0; ElmtsLen1 >= INDEFINITE_LEN; ElmtsLen1++)
	{
		ComponentAttributeTypeAndValue **tmpVar;
		if( !(strLen = LocateNextGSERToken(b, &peek_head, GSER_NO_COPY)) ){
			Asn1Error("Error during Reading{ in encoding");
			return LDAP_PROTOCOL_ERROR;
		}
		if(*peek_head == '}') break;
		if( !(*peek_head == '{' || *peek_head ==',') ) {
			return LDAP_PROTOCOL_ERROR;
		}
		tmpVar = (ComponentAttributeTypeAndValue**) AsnListAppend (&k->comp_list);
		if ( tmpVar == NULL ) {
			Asn1Error("Error during Reading{ in encoding");
			return LDAP_PROTOCOL_ERROR;
		}
	GDecComponentAttributeTypeAndValue (b, tmpVar, bytesDecoded, mode);
	} /* end of for */

	if( !(old_mode & DEC_ALLOC_MODE_1) ) {
	*v = t = (ComponentRelativeDistinguishedName*) malloc( sizeof(ComponentRelativeDistinguishedName) );
	if ( !t ) return -1;
	*t = *k;
	}
	t->syntax = (Syntax*)NULL;
	t->comp_desc = malloc( sizeof( ComponentDesc ) );
	if ( !t->comp_desc ) {
		free ( t );
		return -1;
	}
	t->comp_desc->cd_gser_decoder = (gser_decoder_func*)GDecComponentRelativeDistinguishedName ;
	t->comp_desc->cd_ber_decoder = (ber_decoder_func*)BDecComponentRelativeDistinguishedName ;
	t->comp_desc->cd_free = (comp_free_func*)FreeComponentRelativeDistinguishedName ;
	t->comp_desc->cd_extract_i = (extract_component_from_id_func*)ExtractingComponentRelativeDistinguishedName;
	t->comp_desc->cd_type = ASN_COMPOSITE;
	t->comp_desc->cd_type_id = COMPOSITE_ASN1_TYPE;
	t->comp_desc->cd_all_match = (allcomponent_matching_func*)MatchingComponentRelativeDistinguishedName;
	return LDAP_SUCCESS;
}  /* GDecRelativeDistinguishedNameContent */

void FreeComponentRelativeDistinguishedName(ComponentRelativeDistinguishedName *v)
{

	AsnListNode *l;
	AsnListNode *tmp;
	if(v == NULL)
		return;
	for (l = FIRST_LIST_NODE (&v->comp_list); l != NULL; )
	{
		FreeComponentAttributeTypeAndValue ((l->data));
		tmp = l->next;
		free (((ComponentSyntaxInfo*)l->data)->csi_comp_desc);
		free (l->data);
		free (l);
		l = tmp;
	}
}  /* FreeRelativeDistinguishedName */


int
MatchingComponentRDNSequence ( char* oid, ComponentSyntaxInfo* csi_attr, ComponentSyntaxInfo* csi_assert ) {
	int rc;
	MatchingRule* mr;
	void* component1, *component2;
	AsnList *v1, *v2, t_list;


	if ( oid ) {
		mr = retrieve_matching_rule( oid, csi_attr->csi_comp_desc->cd_type_id);
		if ( mr ) return component_value_match( mr, csi_attr, csi_assert );
	}

	v1 = &((ComponentRDNSequence*)csi_attr)->comp_list;
	v2 = &((ComponentRDNSequence*)csi_assert)->comp_list;
	FOR_EACH_LIST_PAIR_ELMT(component1, component2, v1, v2)
	{
		if( MatchingComponentRelativeDistinguishedName(oid, (ComponentSyntaxInfo*)component1, (ComponentSyntaxInfo*)component2) == LDAP_COMPARE_FALSE) {
			return LDAP_COMPARE_FALSE;
		}
	} /* end of for */

	AsnListFirst(v1);
	AsnListFirst(v2);

	if( (!component1 && component2) || (component1 && !component2))
		return LDAP_COMPARE_FALSE;
	else
		return LDAP_COMPARE_TRUE;
}  /* BMatchingComponentRDNSequenceContent */

void*
ExtractingComponentRDNSequence ( ComponentReference* cr, ComponentRDNSequence *comp )
{
	int count = 0;
	int total;
	AsnList *v = &comp->comp_list;
	ComponentInt *k;
	ComponentRelativeDistinguishedName *component;


	switch ( cr->cr_curr->ci_type ) {
	case LDAP_COMPREF_FROM_BEGINNING :
		count = cr->cr_curr->ci_val.ci_from_beginning;
		FOR_EACH_LIST_ELMT( component , v ) {
			if( --count == 0 ) {
				if( cr->cr_curr->ci_next == NULL )
					return component;
				else {
					cr->cr_curr = cr->cr_curr->ci_next;
					return
	ExtractingComponentRelativeDistinguishedName ( cr, component );
				}
			}
		}
		break;
	case LDAP_COMPREF_FROM_END :
		total = AsnListCount ( v );
		count = cr->cr_curr->ci_val.ci_from_end;
		count = total + count +1;
		FOR_EACH_LIST_ELMT ( component, v ) {
			if( --count == 0 ) {
				if( cr->cr_curr->ci_next == NULL ) 
					return component;
				else {
					cr->cr_curr = cr->cr_curr->ci_next;
					return
	ExtractingComponentRelativeDistinguishedName ( cr, component );
				}
			}
		}
		break;
	case LDAP_COMPREF_ALL :
		return comp;
		k = (ComponentInt*)malloc(sizeof(ComponentInt));
		k->comp_desc = malloc( sizeof( ComponentDesc ) );
		k->comp_desc->cd_tag = NULL;
		k->comp_desc->cd_gser_decoder = (gser_decoder_func*)GDecComponentInt;
		k->comp_desc->cd_ber_decoder = (ber_decoder_func*)BDecComponentInt;
		k->comp_desc->cd_extract_i = (extract_component_from_id_func*)NULL;
		k->comp_desc->cd_type = ASN_BASIC;
		k->comp_desc->cd_type_id = BASICTYPE_INTEGER;
		k->comp_desc->cd_all_match = (allcomponent_matching_func*)MatchingComponentInt;
		k->value = AsnListCount(v);
		return k;
	default :
		return NULL;
	}
}  /* ExtractingComponentRDNSequence */

int
BDecComponentRDNSequence PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, mode),
GenBuf * b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
ComponentRDNSequence **v _AND_
AsnLen *bytesDecoded _AND_
int mode)
{
    int seqDone = FALSE, old_mode = mode;
	AsnLen totalElmtsLen1 = 0;
	AsnLen elmtLen1;
	AsnTag tagId1;
	int mandatoryElmtCount1 = 0;
	ComponentRDNSequence *k, *t, c_temp;


	if ( !(mode & DEC_ALLOC_MODE_1) ) {
	memset(&c_temp,0,sizeof(c_temp));
		 k = &c_temp;
	} else
		 k = t = *v;
	mode = DEC_ALLOC_MODE_2;
	AsnListInit(&k->comp_list,sizeof(ComponentRelativeDistinguishedName));
    for (totalElmtsLen1 = 0; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
    {
        ComponentRelativeDistinguishedName **tmpVar;
    tagId1 = BDecTag (b, &totalElmtsLen1 );

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1 )
        break; /* got EOC so can exit this SET OF/SEQ OF's for loop*/
    }
    if ((tagId1 == MAKE_TAG_ID (UNIV, CONS, SET_TAG_CODE)))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1 );
    tmpVar = (ComponentRelativeDistinguishedName**) AsnListAppend (&k->comp_list);
	BDecComponentRelativeDistinguishedName (b, tagId1, elmtLen1, tmpVar, &totalElmtsLen1, mode);
    }  /* end of tag check if */
    else  /* wrong tag */
    {
         Asn1Error ("Unexpected Tag\n");
         return -1;
    }
    } /* end of for */

	if( !(old_mode & DEC_ALLOC_MODE_1) ) {
	*v = t = (ComponentRDNSequence*) malloc( sizeof(ComponentRDNSequence) );
	if ( !t ) return -1;
	*t = *k;
	}
	t->syntax = (Syntax*)NULL;
	t->comp_desc = malloc( sizeof( ComponentDesc ) );
	if ( !t->comp_desc ) {
		free ( t );
		return -1;
	}
	t->comp_desc->cd_gser_decoder = (gser_decoder_func*)GDecComponentRDNSequence ;
	t->comp_desc->cd_ber_decoder = (ber_decoder_func*)BDecComponentRDNSequence ;
	t->comp_desc->cd_free = (comp_free_func*)FreeComponentRDNSequence ;
	t->comp_desc->cd_extract_i = (extract_component_from_id_func*)ExtractingComponentRDNSequence;
	t->comp_desc->cd_type = ASN_COMPOSITE;
	t->comp_desc->cd_type_id = COMPOSITE_ASN1_TYPE;
	t->comp_desc->cd_all_match = (allcomponent_matching_func*)MatchingComponentRDNSequence;
    (*bytesDecoded) += totalElmtsLen1;
	return LDAP_SUCCESS;
}  /* BDecRDNSequenceContent */

int
GDecComponentRDNSequence PARAMS ((b, v, bytesDecoded, mode),
GenBuf * b _AND_
ComponentRDNSequence **v _AND_
AsnLen *bytesDecoded _AND_
int mode)
{
	char* peek_head,*peek_head2;
	int i, strLen,strLen2, rc, old_mode = mode;
	ComponentRDNSequence *k,*t, c_temp;


	int ElmtsLen1;
	if ( !(mode & DEC_ALLOC_MODE_1) ) {
	memset(&c_temp,0,sizeof(c_temp));
		 k = &c_temp;
	} else
		 k = t = *v;
	mode = DEC_ALLOC_MODE_2;
	AsnListInit( &k->comp_list, sizeof( ComponentRelativeDistinguishedName ) );
	*bytesDecoded = 0;
	if( !(strLen = LocateNextGSERToken(b, &peek_head, GSER_PEEK)) ){
		Asn1Error("Error during Reading { in encoding");
		return LDAP_PROTOCOL_ERROR;
	}
	if(*peek_head != '{'){
		Asn1Error("Missing { in encoded data");
		return LDAP_PROTOCOL_ERROR;
	}

	for (ElmtsLen1 = 0; ElmtsLen1 >= INDEFINITE_LEN; ElmtsLen1++)
	{
		ComponentRelativeDistinguishedName **tmpVar;
		if( !(strLen = LocateNextGSERToken(b, &peek_head, GSER_NO_COPY)) ){
			Asn1Error("Error during Reading{ in encoding");
			return LDAP_PROTOCOL_ERROR;
		}
		if(*peek_head == '}') break;
		if( !(*peek_head == '{' || *peek_head ==',') ) {
			return LDAP_PROTOCOL_ERROR;
		}
		tmpVar = (ComponentRelativeDistinguishedName**) AsnListAppend (&k->comp_list);
		if ( tmpVar == NULL ) {
			Asn1Error("Error during Reading{ in encoding");
			return LDAP_PROTOCOL_ERROR;
		}
	GDecComponentRelativeDistinguishedName (b, tmpVar, bytesDecoded, mode);
	} /* end of for */

	if( !(old_mode & DEC_ALLOC_MODE_1) ) {
	*v = t = (ComponentRDNSequence*) malloc( sizeof(ComponentRDNSequence) );
	if ( !t ) return -1;
	*t = *k;
	}
	t->syntax = (Syntax*)NULL;
	t->comp_desc = malloc( sizeof( ComponentDesc ) );
	if ( !t->comp_desc ) {
		free ( t );
		return -1;
	}
	t->comp_desc->cd_gser_decoder = (gser_decoder_func*)GDecComponentRDNSequence ;
	t->comp_desc->cd_ber_decoder = (ber_decoder_func*)BDecComponentRDNSequence ;
	t->comp_desc->cd_free = (comp_free_func*)FreeComponentRDNSequence ;
	t->comp_desc->cd_extract_i = (extract_component_from_id_func*)ExtractingComponentRDNSequence;
	t->comp_desc->cd_type = ASN_COMPOSITE;
	t->comp_desc->cd_type_id = COMPOSITE_ASN1_TYPE;
	t->comp_desc->cd_all_match = (allcomponent_matching_func*)MatchingComponentRDNSequence;
	return LDAP_SUCCESS;
}  /* GDecRDNSequenceContent */

void FreeComponentRDNSequence(ComponentRDNSequence *v)
{

	AsnListNode *l;
	AsnListNode *tmp;
	if(v == NULL)
		return;
	for (l = FIRST_LIST_NODE (&v->comp_list); l != NULL; )
	{
		FreeComponentRelativeDistinguishedName ((l->data));
		tmp = l->next;
		free (((ComponentSyntaxInfo*)l->data)->csi_comp_desc);
		free (l->data);
		free (l);
		l = tmp;
	}
}  /* FreeRDNSequence */


int
MatchingComponentName ( char* oid, ComponentSyntaxInfo* csi_attr, ComponentSyntaxInfo* csi_assert ) {
	int rc;
	MatchingRule* mr;
	ComponentName *v1, *v2;


	v1 = (ComponentName*)csi_attr;
	v2 = (ComponentName*)csi_assert;
	if ( oid ) {
		mr = retrieve_matching_rule( oid, csi_attr->csi_comp_desc->cd_type_id);
		if ( mr ) return component_value_match( mr, csi_attr, csi_assert );
	}

	if( (v1->choiceId != v2->choiceId ) )
		return LDAP_COMPARE_FALSE;
	switch( v1->choiceId )
	{
	   case NAME_RDNSEQUENCE :
		rc = 	MatchingComponentRDNSequence ( oid, (ComponentSyntaxInfo*)(v1->a.rdnSequence), (ComponentSyntaxInfo*)(v2->a.rdnSequence) );
		break;
	default : 
		 return LDAP_PROTOCOL_ERROR;
	}
	return rc;
}  /* BMatchingComponentNameContent */

void*
ExtractingComponentName ( ComponentReference* cr, ComponentName *comp )
{


	if( (comp->choiceId) ==  NAME_RDNSEQUENCE &&
		 ((strncmp(comp->a.rdnSequence->identifier.bv_val, cr->cr_curr->ci_val.ci_identifier.bv_val,cr->cr_curr->ci_val.ci_identifier.bv_len) == 0) ||
		 ( strncmp(comp->a.rdnSequence->id_buf, cr->cr_curr->ci_val.ci_identifier.bv_val,cr->cr_curr->ci_val.ci_identifier.bv_len) == 0))) {
		if ( cr->cr_curr->ci_next == NULL )
			return (comp->a.rdnSequence);
		else {
			cr->cr_curr = cr->cr_curr->ci_next;
			return 	ExtractingComponentRDNSequence ( cr, (comp->a.rdnSequence) );
		};
	}
	return NULL;
}  /* ExtractingComponentName */

int
BDecComponentName PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, mode),
GenBuf * b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
ComponentName **v _AND_
AsnLen *bytesDecoded _AND_
int mode)
{
    int seqDone = FALSE, old_mode = mode;
	AsnLen totalElmtsLen1 = 0;
	AsnLen elmtLen1;
	AsnTag tagId1;
	int mandatoryElmtCount1 = 0;
	ComponentName *k, *t, c_temp;


	if ( !(mode & DEC_ALLOC_MODE_1) ) {
	memset(&c_temp,0,sizeof(c_temp));
		 k = &c_temp;
	} else
		 k = t = *v;
	mode = DEC_ALLOC_MODE_2;
    switch (tagId0)
    {
       case MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE):
        (k->choiceId) = NAME_RDNSEQUENCE;
	BDecComponentRDNSequence (b, tagId0, elmtLen0, (&k->a.rdnSequence), &totalElmtsLen1, mode);
		(k->a.rdnSequence)->identifier.bv_val = (k->a.rdnSequence)->id_buf;
		(k->a.rdnSequence)->identifier.bv_len = strlen("rdnSequence");
		strcpy( (k->a.rdnSequence)->identifier.bv_val, "rdnSequence");
    break;

    default:
        Asn1Error ("ERROR - unexpected tag in CHOICE\n");
        return -1;
        break;
    } /* end switch */
	if( !(old_mode & DEC_ALLOC_MODE_1) ) {
	*v = t = (ComponentName*) malloc( sizeof(ComponentName) );
	if ( !t ) return -1;
	*t = *k;
	}
	t->syntax = (Syntax*)NULL;
	t->comp_desc = malloc( sizeof( ComponentDesc ) );
	if ( !t->comp_desc ) {
		free ( t );
		return -1;
	}
	t->comp_desc->cd_gser_decoder = (gser_decoder_func*)GDecComponentName ;
	t->comp_desc->cd_ber_decoder = (ber_decoder_func*)BDecComponentName ;
	t->comp_desc->cd_free = (comp_free_func*)FreeComponentName ;
	t->comp_desc->cd_extract_i = (extract_component_from_id_func*)ExtractingComponentName;
	t->comp_desc->cd_type = ASN_COMPOSITE;
	t->comp_desc->cd_type_id = COMPOSITE_ASN1_TYPE;
	t->comp_desc->cd_all_match = (allcomponent_matching_func*)MatchingComponentName;
    (*bytesDecoded) += totalElmtsLen1;
	return LDAP_SUCCESS;
}  /* BDecNameContent */

int
GDecComponentName PARAMS ((b, v, bytesDecoded, mode),
GenBuf * b _AND_
ComponentName **v _AND_
AsnLen *bytesDecoded _AND_
int mode)
{
	char* peek_head,*peek_head2;
	int i, strLen,strLen2, rc, old_mode = mode;
	ComponentName *k,*t, c_temp;


	if ( !(mode & DEC_ALLOC_MODE_1) ) {
	memset(&c_temp,0,sizeof(c_temp));
		 k = &c_temp;
	} else
		 k = t = *v;
	mode = DEC_ALLOC_MODE_2;
	if( !(strLen = LocateNextGSERToken(b,&peek_head,GSER_NO_COPY)) ){
		Asn1Error("Error during Reading identifier");
		return LDAP_PROTOCOL_ERROR;
	}
	if( !(strLen2 = LocateNextGSERToken(b,&peek_head2,GSER_NO_COPY)) ){
		Asn1Error("Error during Reading identifier");
		return LDAP_PROTOCOL_ERROR;
	}
	if(*peek_head2 != ':'){
		Asn1Error("Missing : in encoded data");
		return LDAP_PROTOCOL_ERROR;
	}
	if( strncmp("rdnSequence",peek_head,sizeof("rdnSequence")-1) == 0){
		(k->choiceId) = NAME_RDNSEQUENCE;
		rc = 	GDecComponentRDNSequence (b, (&k->a.rdnSequence), bytesDecoded, mode);
		if ( rc != LDAP_SUCCESS ) return rc;
		(k->a.rdnSequence)->identifier.bv_val = peek_head;
		(k->a.rdnSequence)->identifier.bv_len = strLen;
	}
	else {
		Asn1Error("Undefined Identifier");
		return LDAP_PROTOCOL_ERROR;
	}
	if( !(old_mode & DEC_ALLOC_MODE_1) ) {
	*v = t = (ComponentName*) malloc( sizeof(ComponentName) );
	if ( !t ) return -1;
	*t = *k;
	}
	t->syntax = (Syntax*)NULL;
	t->comp_desc = malloc( sizeof( ComponentDesc ) );
	if ( !t->comp_desc ) {
		free ( t );
		return -1;
	}
	t->comp_desc->cd_gser_decoder = (gser_decoder_func*)GDecComponentName ;
	t->comp_desc->cd_ber_decoder = (ber_decoder_func*)BDecComponentName ;
	t->comp_desc->cd_free = (comp_free_func*)FreeComponentName ;
	t->comp_desc->cd_extract_i = (extract_component_from_id_func*)ExtractingComponentName;
	t->comp_desc->cd_type = ASN_COMPOSITE;
	t->comp_desc->cd_type_id = COMPOSITE_ASN1_TYPE;
	t->comp_desc->cd_all_match = (allcomponent_matching_func*)MatchingComponentName;
	return LDAP_SUCCESS;
}  /* GDecNameContent */

void FreeComponentName(ComponentName *v)
{

	if(v == NULL)
		return;
		switch(v->choiceId)
    {
	   case NAME_RDNSEQUENCE:
	FreeComponentRDNSequence((v->a.rdnSequence));
	free ((v->a.rdnSequence)->comp_desc);
	free ((v->a.rdnSequence));

	break;

	}
}  /* FreeName */


int
MatchingComponentTBSCertificate ( char* oid, ComponentSyntaxInfo* csi_attr, ComponentSyntaxInfo* csi_assert ) {
	int rc;
	MatchingRule* mr;

	if ( oid ) {
		mr = retrieve_matching_rule( oid, csi_attr->csi_comp_desc->cd_type_id);
		if ( mr ) return component_value_match( mr, csi_attr, csi_assert );
	}

	rc = 1;
	rc =	MatchingComponentVersion ( oid, (ComponentSyntaxInfo*)((ComponentTBSCertificate*)csi_attr)->version, (ComponentSyntaxInfo*)((ComponentTBSCertificate*)csi_assert)->version );
	if ( rc != LDAP_COMPARE_TRUE )
		return rc;
	rc =	MatchingComponentCertificateSerialNumber ( oid, (ComponentSyntaxInfo*)&((ComponentTBSCertificate*)csi_attr)->serialNumber, (ComponentSyntaxInfo*)&((ComponentTBSCertificate*)csi_assert)->serialNumber );
	if ( rc != LDAP_COMPARE_TRUE )
		return rc;
	rc =	MatchingComponentAlgorithmIdentifier ( oid, (ComponentSyntaxInfo*)((ComponentTBSCertificate*)csi_attr)->signature, (ComponentSyntaxInfo*)((ComponentTBSCertificate*)csi_assert)->signature );
	if ( rc != LDAP_COMPARE_TRUE )
		return rc;
	rc =	MatchingComponentName ( oid, (ComponentSyntaxInfo*)((ComponentTBSCertificate*)csi_attr)->issuer, (ComponentSyntaxInfo*)((ComponentTBSCertificate*)csi_assert)->issuer );
	if ( rc != LDAP_COMPARE_TRUE )
		return rc;
	rc =	MatchingComponentValidity ( oid, (ComponentSyntaxInfo*)((ComponentTBSCertificate*)csi_attr)->validity, (ComponentSyntaxInfo*)((ComponentTBSCertificate*)csi_assert)->validity );
	if ( rc != LDAP_COMPARE_TRUE )
		return rc;
	rc =	MatchingComponentName ( oid, (ComponentSyntaxInfo*)((ComponentTBSCertificate*)csi_attr)->subject, (ComponentSyntaxInfo*)((ComponentTBSCertificate*)csi_assert)->subject );
	if ( rc != LDAP_COMPARE_TRUE )
		return rc;
	rc =	MatchingComponentSubjectPublicKeyInfo ( oid, (ComponentSyntaxInfo*)((ComponentTBSCertificate*)csi_attr)->subjectPublicKeyInfo, (ComponentSyntaxInfo*)((ComponentTBSCertificate*)csi_assert)->subjectPublicKeyInfo );
	if ( rc != LDAP_COMPARE_TRUE )
		return rc;
	rc =	MatchingComponentUniqueIdentifier ( oid, (ComponentSyntaxInfo*)&((ComponentTBSCertificate*)csi_attr)->issuerUniqueIdentifier, (ComponentSyntaxInfo*)&((ComponentTBSCertificate*)csi_assert)->issuerUniqueIdentifier );
	if ( rc != LDAP_COMPARE_TRUE )
		return rc;
	rc =	MatchingComponentUniqueIdentifier ( oid, (ComponentSyntaxInfo*)&((ComponentTBSCertificate*)csi_attr)->subjectUniqueIdentifier, (ComponentSyntaxInfo*)&((ComponentTBSCertificate*)csi_assert)->subjectUniqueIdentifier );
	if ( rc != LDAP_COMPARE_TRUE )
		return rc;
	rc =	MatchingComponentExtensions ( oid, (ComponentSyntaxInfo*)((ComponentTBSCertificate*)csi_attr)->extensions, (ComponentSyntaxInfo*)((ComponentTBSCertificate*)csi_assert)->extensions );
	if ( rc != LDAP_COMPARE_TRUE )
		return rc;
	return LDAP_COMPARE_TRUE;
}  /* BMatchingComponentTBSCertificate */

void*
ExtractingComponentTBSCertificate ( ComponentReference* cr, ComponentTBSCertificate *comp )
{

	if ( ( strncmp(comp->version->identifier.bv_val, cr->cr_curr->ci_val.ci_identifier.bv_val,cr->cr_curr->ci_val.ci_identifier.bv_len) == 0 ) || ( strncmp(comp->version->id_buf, cr->cr_curr->ci_val.ci_identifier.bv_val,cr->cr_curr->ci_val.ci_identifier.bv_len) == 0 ) ) {
		if ( cr->cr_curr->ci_next == NULL )
			return comp->version;
		else {
			cr->cr_curr = cr->cr_curr->ci_next;
			return 	ExtractingComponentVersion ( cr, comp->version );
		}
	}
	if ( ( strncmp(comp->serialNumber.identifier.bv_val, cr->cr_curr->ci_val.ci_identifier.bv_val,cr->cr_curr->ci_val.ci_identifier.bv_len) == 0 ) || ( strncmp(comp->serialNumber.id_buf, cr->cr_curr->ci_val.ci_identifier.bv_val,cr->cr_curr->ci_val.ci_identifier.bv_len) == 0 ) ) {
		if ( cr->cr_curr->ci_next == NULL )
		return &comp->serialNumber;
		else
		return NULL;
	}
	if ( ( strncmp(comp->signature->identifier.bv_val, cr->cr_curr->ci_val.ci_identifier.bv_val,cr->cr_curr->ci_val.ci_identifier.bv_len) == 0 ) || ( strncmp(comp->signature->id_buf, cr->cr_curr->ci_val.ci_identifier.bv_val,cr->cr_curr->ci_val.ci_identifier.bv_len) == 0 ) ) {
		if ( cr->cr_curr->ci_next == NULL )
			return comp->signature;
		else {
			cr->cr_curr = cr->cr_curr->ci_next;
			return 	ExtractingComponentAlgorithmIdentifier ( cr, comp->signature );
		}
	}
	if ( ( strncmp(comp->issuer->identifier.bv_val, cr->cr_curr->ci_val.ci_identifier.bv_val,cr->cr_curr->ci_val.ci_identifier.bv_len) == 0 ) || ( strncmp(comp->issuer->id_buf, cr->cr_curr->ci_val.ci_identifier.bv_val,cr->cr_curr->ci_val.ci_identifier.bv_len) == 0 ) ) {
		if ( cr->cr_curr->ci_next == NULL )
			return comp->issuer;
		else {
			cr->cr_curr = cr->cr_curr->ci_next;
			return 	ExtractingComponentName ( cr, comp->issuer );
		}
	}
	if ( ( strncmp(comp->validity->identifier.bv_val, cr->cr_curr->ci_val.ci_identifier.bv_val,cr->cr_curr->ci_val.ci_identifier.bv_len) == 0 ) || ( strncmp(comp->validity->id_buf, cr->cr_curr->ci_val.ci_identifier.bv_val,cr->cr_curr->ci_val.ci_identifier.bv_len) == 0 ) ) {
		if ( cr->cr_curr->ci_next == NULL )
			return comp->validity;
		else {
			cr->cr_curr = cr->cr_curr->ci_next;
			return 	ExtractingComponentValidity ( cr, comp->validity );
		}
	}
	if ( ( strncmp(comp->subject->identifier.bv_val, cr->cr_curr->ci_val.ci_identifier.bv_val,cr->cr_curr->ci_val.ci_identifier.bv_len) == 0 ) || ( strncmp(comp->subject->id_buf, cr->cr_curr->ci_val.ci_identifier.bv_val,cr->cr_curr->ci_val.ci_identifier.bv_len) == 0 ) ) {
		if ( cr->cr_curr->ci_next == NULL )
			return comp->subject;
		else {
			cr->cr_curr = cr->cr_curr->ci_next;
			return 	ExtractingComponentName ( cr, comp->subject );
		}
	}
	if ( ( strncmp(comp->subjectPublicKeyInfo->identifier.bv_val, cr->cr_curr->ci_val.ci_identifier.bv_val,cr->cr_curr->ci_val.ci_identifier.bv_len) == 0 ) || ( strncmp(comp->subjectPublicKeyInfo->id_buf, cr->cr_curr->ci_val.ci_identifier.bv_val,cr->cr_curr->ci_val.ci_identifier.bv_len) == 0 ) ) {
		if ( cr->cr_curr->ci_next == NULL )
			return comp->subjectPublicKeyInfo;
		else {
			cr->cr_curr = cr->cr_curr->ci_next;
			return 	ExtractingComponentSubjectPublicKeyInfo ( cr, comp->subjectPublicKeyInfo );
		}
	}
	if ( ( strncmp(comp->issuerUniqueIdentifier.identifier.bv_val, cr->cr_curr->ci_val.ci_identifier.bv_val,cr->cr_curr->ci_val.ci_identifier.bv_len) == 0 ) || ( strncmp(comp->issuerUniqueIdentifier.id_buf, cr->cr_curr->ci_val.ci_identifier.bv_val,cr->cr_curr->ci_val.ci_identifier.bv_len) == 0 ) ) {
		if ( cr->cr_curr->ci_next == NULL )
		return &comp->issuerUniqueIdentifier;
		else
		return NULL;
	}
	if ( ( strncmp(comp->subjectUniqueIdentifier.identifier.bv_val, cr->cr_curr->ci_val.ci_identifier.bv_val,cr->cr_curr->ci_val.ci_identifier.bv_len) == 0 ) || ( strncmp(comp->subjectUniqueIdentifier.id_buf, cr->cr_curr->ci_val.ci_identifier.bv_val,cr->cr_curr->ci_val.ci_identifier.bv_len) == 0 ) ) {
		if ( cr->cr_curr->ci_next == NULL )
		return &comp->subjectUniqueIdentifier;
		else
		return NULL;
	}
	if ( ( strncmp(comp->extensions->identifier.bv_val, cr->cr_curr->ci_val.ci_identifier.bv_val,cr->cr_curr->ci_val.ci_identifier.bv_len) == 0 ) || ( strncmp(comp->extensions->id_buf, cr->cr_curr->ci_val.ci_identifier.bv_val,cr->cr_curr->ci_val.ci_identifier.bv_len) == 0 ) ) {
		if ( cr->cr_curr->ci_next == NULL )
			return comp->extensions;
		else {
			cr->cr_curr = cr->cr_curr->ci_next;
			return 	ExtractingComponentExtensions ( cr, comp->extensions );
		}
	}
	return NULL;
}  /* ExtractingComponentTBSCertificate */

int
BDecComponentTBSCertificate PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, mode),
GenBuf * b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
ComponentTBSCertificate **v _AND_
AsnLen *bytesDecoded _AND_
int mode)
{
    int seqDone = FALSE, old_mode = mode;
	AsnLen totalElmtsLen1 = 0;
	AsnLen elmtLen1;
	AsnTag tagId1;
	int mandatoryElmtCount1 = 0;
	AsnLen totalElmtsLen2 = 0;
	AsnLen elmtLen2;
	AsnTag tagId2;
	ComponentTBSCertificate *k, *t, c_temp;


	if ( !(mode & DEC_ALLOC_MODE_1) ) {
	memset(&c_temp,0,sizeof(c_temp));
		 k = &c_temp;
	} else
		 k = t = *v;
	mode = DEC_ALLOC_MODE_2;
    tagId1 = BDecTag (b, &totalElmtsLen1 );

    if (((tagId1 == MAKE_TAG_ID (CNTX, CONS, 0))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1 );
        tagId2 = BDecTag (b, &totalElmtsLen1 );

    if (tagId2 != MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE))
    {
         Asn1Error ("Unexpected Tag\n");
         return -1;
    }

    elmtLen2 = BDecLen (b, &totalElmtsLen1 );
	BDecComponentVersion (b, tagId2, elmtLen2, (&k->version), &totalElmtsLen1, DEC_ALLOC_MODE_0 );
		(k->version)->identifier.bv_val = (k->version)->id_buf;
		(k->version)->identifier.bv_len = strlen("version");
		strcpy( (k->version)->identifier.bv_val, "version");
	if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1 );
    tagId1 = BDecTag (b, &totalElmtsLen1);
    }


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1 );
	BDecComponentCertificateSerialNumber (b, tagId1, elmtLen1, (&k->serialNumber), &totalElmtsLen1, mode);
		(&k->serialNumber)->identifier.bv_val = (&k->serialNumber)->id_buf;
		(&k->serialNumber)->identifier.bv_len = strlen("serialNumber");
		strcpy( (&k->serialNumber)->identifier.bv_val, "serialNumber");
    tagId1 = BDecTag (b, &totalElmtsLen1);
    }
    else
        return -1;



    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1 );
	BDecComponentAlgorithmIdentifier (b, tagId1, elmtLen1, (&k->signature), &totalElmtsLen1, mode);
		(k->signature)->identifier.bv_val = (k->signature)->id_buf;
		(k->signature)->identifier.bv_len = strlen("signature");
		strcpy( (k->signature)->identifier.bv_val, "signature");
    tagId1 = BDecTag (b, &totalElmtsLen1);
    }
    else
        return -1;



    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1 );
	BDecComponentName (b, tagId1, elmtLen1, (&k->issuer), &totalElmtsLen1, mode);
		(k->issuer)->identifier.bv_val = (k->issuer)->id_buf;
		(k->issuer)->identifier.bv_len = strlen("issuer");
		strcpy( (k->issuer)->identifier.bv_val, "issuer");
    tagId1 = BDecTag (b, &totalElmtsLen1);
    }
    else
        return -1;



    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1 );
	BDecComponentValidity (b, tagId1, elmtLen1, (&k->validity), &totalElmtsLen1, mode);
		(k->validity)->identifier.bv_val = (k->validity)->id_buf;
		(k->validity)->identifier.bv_len = strlen("validity");
		strcpy( (k->validity)->identifier.bv_val, "validity");
    tagId1 = BDecTag (b, &totalElmtsLen1);
    }
    else
        return -1;



    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1 );
	BDecComponentName (b, tagId1, elmtLen1, (&k->subject), &totalElmtsLen1, mode);
		(k->subject)->identifier.bv_val = (k->subject)->id_buf;
		(k->subject)->identifier.bv_len = strlen("subject");
		strcpy( (k->subject)->identifier.bv_val, "subject");
    tagId1 = BDecTag (b, &totalElmtsLen1);
    }
    else
        return -1;



    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1 );
	BDecComponentSubjectPublicKeyInfo (b, tagId1, elmtLen1, (&k->subjectPublicKeyInfo), &totalElmtsLen1, mode);
		(k->subjectPublicKeyInfo)->identifier.bv_val = (k->subjectPublicKeyInfo)->id_buf;
		(k->subjectPublicKeyInfo)->identifier.bv_len = strlen("subjectPublicKeyInfo");
		strcpy( (k->subjectPublicKeyInfo)->identifier.bv_val, "subjectPublicKeyInfo");
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1 );

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1 )
            seqDone = TRUE;
        }
    }
    }
    else
        return -1;



    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (CNTX, PRIM, 1)) ||
(tagId1 == MAKE_TAG_ID (CNTX, CONS, 1))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1 );
	BDecComponentUniqueIdentifier (b, tagId1, elmtLen1, (&k->issuerUniqueIdentifier), &totalElmtsLen1, mode);
		(&k->issuerUniqueIdentifier)->identifier.bv_val = (&k->issuerUniqueIdentifier)->id_buf;
		(&k->issuerUniqueIdentifier)->identifier.bv_len = strlen("issuerUniqueIdentifier");
		strcpy( (&k->issuerUniqueIdentifier)->identifier.bv_val, "issuerUniqueIdentifier");
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1 );

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1 )
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (CNTX, PRIM, 2)) ||
(tagId1 == MAKE_TAG_ID (CNTX, CONS, 2))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1 );
	BDecComponentUniqueIdentifier (b, tagId1, elmtLen1, (&k->subjectUniqueIdentifier), &totalElmtsLen1, mode);
		(&k->subjectUniqueIdentifier)->identifier.bv_val = (&k->subjectUniqueIdentifier)->id_buf;
		(&k->subjectUniqueIdentifier)->identifier.bv_len = strlen("subjectUniqueIdentifier");
		strcpy( (&k->subjectUniqueIdentifier)->identifier.bv_val, "subjectUniqueIdentifier");
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1 );

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1 )
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (CNTX, CONS, 3))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1 );
        tagId2 = BDecTag (b, &totalElmtsLen1 );

    if (tagId2 != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
    {
         Asn1Error ("Unexpected Tag\n");
         return -1;
    }

    elmtLen2 = BDecLen (b, &totalElmtsLen1 );
	BDecComponentExtensions (b, tagId2, elmtLen2, (&k->extensions), &totalElmtsLen1, mode);
		(k->extensions)->identifier.bv_val = (k->extensions)->id_buf;
		(k->extensions)->identifier.bv_len = strlen("extensions");
		strcpy( (k->extensions)->identifier.bv_val, "extensions");
	if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1 );
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1 );
        else if (totalElmtsLen1 != elmtLen0)
        return -1;

    }


    if (!seqDone)
        return -1;

	if( !(old_mode & DEC_ALLOC_MODE_1) ) {
	*v = t = (ComponentTBSCertificate*) malloc( sizeof(ComponentTBSCertificate) );
	if ( !t ) return -1;
	*t = *k;
	}
	t->syntax = (Syntax*)NULL;
	t->comp_desc = malloc( sizeof( ComponentDesc ) );
	if ( !t->comp_desc ) {
		free ( t );
		return -1;
	}
	t->comp_desc->cd_gser_decoder = (gser_decoder_func*)GDecComponentTBSCertificate ;
	t->comp_desc->cd_ber_decoder = (ber_decoder_func*)BDecComponentTBSCertificate ;
	t->comp_desc->cd_free = (comp_free_func*)FreeComponentTBSCertificate ;
	t->comp_desc->cd_extract_i = (extract_component_from_id_func*)ExtractingComponentTBSCertificate;
	t->comp_desc->cd_type = ASN_COMPOSITE;
	t->comp_desc->cd_type_id = COMPOSITE_ASN1_TYPE;
	t->comp_desc->cd_all_match = (allcomponent_matching_func*)MatchingComponentTBSCertificate;
    (*bytesDecoded) += totalElmtsLen1;
	return LDAP_SUCCESS;
}  /* BDecTBSCertificate*/

int
GDecComponentTBSCertificate PARAMS ((b, v, bytesDecoded, mode),
GenBuf * b _AND_
ComponentTBSCertificate **v _AND_
AsnLen *bytesDecoded _AND_
int mode)
{
	char* peek_head,*peek_head2;
	int i, strLen,strLen2, rc, old_mode = mode;
	ComponentTBSCertificate *k,*t, c_temp;


	if ( !(mode & DEC_ALLOC_MODE_1) ) {
	memset(&c_temp,0,sizeof(c_temp));
		 k = &c_temp;
	} else
		 k = t = *v;
	mode = DEC_ALLOC_MODE_2;
	*bytesDecoded = 0;
	if( !(strLen = LocateNextGSERToken(b,&peek_head,GSER_NO_COPY)) ){
		Asn1Error("Error during Reading , in encoded data");
		return LDAP_PROTOCOL_ERROR;
	}
	if(*peek_head != '{'){
		Asn1Error("Missing { in encoded data");
		return LDAP_PROTOCOL_ERROR;
	}
	if( !(strLen = LocateNextGSERToken(b,&peek_head,GSER_NO_COPY)) ){
	  Asn1Error("Error during Reading identifier");
		return LDAP_PROTOCOL_ERROR;
	}
	GDecComponentVersion (b, (&k->version), bytesDecoded, DEC_ALLOC_MODE_0 );
	( k->version)->identifier.bv_val = peek_head;
	( k->version)->identifier.bv_len = strLen;
	if( !(strLen = LocateNextGSERToken(b,&peek_head,GSER_NO_COPY)) ){
		Asn1Error("Error during Reading { ");
		return LDAP_PROTOCOL_ERROR;
	}
	if(*peek_head != ','){
		Asn1Error("Missing , in encoding");
		return LDAP_PROTOCOL_ERROR;
	}
	if( !(strLen = LocateNextGSERToken(b,&peek_head,GSER_NO_COPY)) ){
	  Asn1Error("Error during Reading identifier");
		return LDAP_PROTOCOL_ERROR;
	}
	GDecComponentCertificateSerialNumber (b, (&k->serialNumber), bytesDecoded, mode);
	(&k->serialNumber)->identifier.bv_val = peek_head;
	(&k->serialNumber)->identifier.bv_len = strLen;
	if( !(strLen = LocateNextGSERToken(b,&peek_head,GSER_NO_COPY)) ){
		Asn1Error("Error during Reading { ");
		return LDAP_PROTOCOL_ERROR;
	}
	if(*peek_head != ','){
		Asn1Error("Missing , in encoding");
		return LDAP_PROTOCOL_ERROR;
	}
	if( !(strLen = LocateNextGSERToken(b,&peek_head,GSER_NO_COPY)) ){
	  Asn1Error("Error during Reading identifier");
		return LDAP_PROTOCOL_ERROR;
	}
	GDecComponentAlgorithmIdentifier (b, (&k->signature), bytesDecoded, mode);
	( k->signature)->identifier.bv_val = peek_head;
	( k->signature)->identifier.bv_len = strLen;
	if( !(strLen = LocateNextGSERToken(b,&peek_head,GSER_NO_COPY)) ){
		Asn1Error("Error during Reading { ");
		return LDAP_PROTOCOL_ERROR;
	}
	if(*peek_head != ','){
		Asn1Error("Missing , in encoding");
		return LDAP_PROTOCOL_ERROR;
	}
	if( !(strLen = LocateNextGSERToken(b,&peek_head,GSER_NO_COPY)) ){
	  Asn1Error("Error during Reading identifier");
		return LDAP_PROTOCOL_ERROR;
	}
	GDecComponentName (b, (&k->issuer), bytesDecoded, mode);
	( k->issuer)->identifier.bv_val = peek_head;
	( k->issuer)->identifier.bv_len = strLen;
	if( !(strLen = LocateNextGSERToken(b,&peek_head,GSER_NO_COPY)) ){
		Asn1Error("Error during Reading { ");
		return LDAP_PROTOCOL_ERROR;
	}
	if(*peek_head != ','){
		Asn1Error("Missing , in encoding");
		return LDAP_PROTOCOL_ERROR;
	}
	if( !(strLen = LocateNextGSERToken(b,&peek_head,GSER_NO_COPY)) ){
	  Asn1Error("Error during Reading identifier");
		return LDAP_PROTOCOL_ERROR;
	}
	GDecComponentValidity (b, (&k->validity), bytesDecoded, mode);
	( k->validity)->identifier.bv_val = peek_head;
	( k->validity)->identifier.bv_len = strLen;
	if( !(strLen = LocateNextGSERToken(b,&peek_head,GSER_NO_COPY)) ){
		Asn1Error("Error during Reading { ");
		return LDAP_PROTOCOL_ERROR;
	}
	if(*peek_head != ','){
		Asn1Error("Missing , in encoding");
		return LDAP_PROTOCOL_ERROR;
	}
	if( !(strLen = LocateNextGSERToken(b,&peek_head,GSER_NO_COPY)) ){
	  Asn1Error("Error during Reading identifier");
		return LDAP_PROTOCOL_ERROR;
	}
	GDecComponentName (b, (&k->subject), bytesDecoded, mode);
	( k->subject)->identifier.bv_val = peek_head;
	( k->subject)->identifier.bv_len = strLen;
	if( !(strLen = LocateNextGSERToken(b,&peek_head,GSER_NO_COPY)) ){
		Asn1Error("Error during Reading { ");
		return LDAP_PROTOCOL_ERROR;
	}
	if(*peek_head != ','){
		Asn1Error("Missing , in encoding");
		return LDAP_PROTOCOL_ERROR;
	}
	if( !(strLen = LocateNextGSERToken(b,&peek_head,GSER_NO_COPY)) ){
	  Asn1Error("Error during Reading identifier");
		return LDAP_PROTOCOL_ERROR;
	}
	GDecComponentSubjectPublicKeyInfo (b, (&k->subjectPublicKeyInfo), bytesDecoded, mode);
	( k->subjectPublicKeyInfo)->identifier.bv_val = peek_head;
	( k->subjectPublicKeyInfo)->identifier.bv_len = strLen;
	if( !(strLen = LocateNextGSERToken(b,&peek_head,GSER_NO_COPY)) ){
		Asn1Error("Error during Reading { ");
		return LDAP_PROTOCOL_ERROR;
	}
	if(*peek_head != ','){
		Asn1Error("Missing , in encoding");
		return LDAP_PROTOCOL_ERROR;
	}
	if( !(strLen = LocateNextGSERToken(b,&peek_head,GSER_NO_COPY)) ){
	  Asn1Error("Error during Reading identifier");
		return LDAP_PROTOCOL_ERROR;
	}
	GDecComponentUniqueIdentifier (b, (&k->issuerUniqueIdentifier), bytesDecoded, mode);
	(&k->issuerUniqueIdentifier)->identifier.bv_val = peek_head;
	(&k->issuerUniqueIdentifier)->identifier.bv_len = strLen;
	if( !(strLen = LocateNextGSERToken(b,&peek_head,GSER_NO_COPY)) ){
		Asn1Error("Error during Reading { ");
		return LDAP_PROTOCOL_ERROR;
	}
	if(*peek_head != ','){
		Asn1Error("Missing , in encoding");
		return LDAP_PROTOCOL_ERROR;
	}
	if( !(strLen = LocateNextGSERToken(b,&peek_head,GSER_NO_COPY)) ){
	  Asn1Error("Error during Reading identifier");
		return LDAP_PROTOCOL_ERROR;
	}
	GDecComponentUniqueIdentifier (b, (&k->subjectUniqueIdentifier), bytesDecoded, mode);
	(&k->subjectUniqueIdentifier)->identifier.bv_val = peek_head;
	(&k->subjectUniqueIdentifier)->identifier.bv_len = strLen;
	if( !(strLen = LocateNextGSERToken(b,&peek_head,GSER_NO_COPY)) ){
		Asn1Error("Error during Reading { ");
		return LDAP_PROTOCOL_ERROR;
	}
	if(*peek_head != ','){
		Asn1Error("Missing , in encoding");
		return LDAP_PROTOCOL_ERROR;
	}
	if( !(strLen = LocateNextGSERToken(b,&peek_head,GSER_NO_COPY)) ){
	  Asn1Error("Error during Reading identifier");
		return LDAP_PROTOCOL_ERROR;
	}
	GDecComponentExtensions (b, (&k->extensions), bytesDecoded, mode);
	( k->extensions)->identifier.bv_val = peek_head;
	( k->extensions)->identifier.bv_len = strLen;
	if( !(strLen = LocateNextGSERToken(b,&peek_head,GSER_NO_COPY)) ) {
		Asn1Error("Error during Reading } in encoding");
		return LDAP_PROTOCOL_ERROR;
	}
	if(*peek_head != '}'){
		Asn1Error("Missing } in encoding");
		return LDAP_PROTOCOL_ERROR;
	}
	if( !(old_mode & DEC_ALLOC_MODE_1) ) {
	*v = t = (ComponentTBSCertificate*) malloc( sizeof(ComponentTBSCertificate) );
	if ( !t ) return -1;
	*t = *k;
	}
	t->syntax = (Syntax*)NULL;
	t->comp_desc = malloc( sizeof( ComponentDesc ) );
	if ( !t->comp_desc ) {
		free ( t );
		return -1;
	}
	t->comp_desc->cd_gser_decoder = (gser_decoder_func*)GDecComponentTBSCertificate ;
	t->comp_desc->cd_ber_decoder = (ber_decoder_func*)BDecComponentTBSCertificate ;
	t->comp_desc->cd_free = (comp_free_func*)FreeComponentTBSCertificate ;
	t->comp_desc->cd_extract_i = (extract_component_from_id_func*)ExtractingComponentTBSCertificate;
	t->comp_desc->cd_type = ASN_COMPOSITE;
	t->comp_desc->cd_type_id = COMPOSITE_ASN1_TYPE;
	t->comp_desc->cd_all_match = (allcomponent_matching_func*)MatchingComponentTBSCertificate;
	return LDAP_SUCCESS;
}  /* GDecTBSCertificate*/

void FreeComponentTBSCertificate(ComponentTBSCertificate *v)
{

	if(v == NULL)
		return;
	if(COMPONENTNOT_NULL ((v->version)))
    {
	FreeComponentVersion((v->version));
	free ((v->version)->comp_desc);
	free ((v->version));

	}

	FreeComponentCertificateSerialNumber((&v->serialNumber));
	free ((v->serialNumber).comp_desc);

	FreeComponentAlgorithmIdentifier((v->signature));
	free ((v->signature)->comp_desc);
	free ((v->signature));

	FreeComponentName((v->issuer));
	free ((v->issuer)->comp_desc);
	free ((v->issuer));

	FreeComponentValidity((v->validity));
	free ((v->validity)->comp_desc);
	free ((v->validity));

	FreeComponentName((v->subject));
	free ((v->subject)->comp_desc);
	free ((v->subject));

	FreeComponentSubjectPublicKeyInfo((v->subjectPublicKeyInfo));
	free ((v->subjectPublicKeyInfo)->comp_desc);
	free ((v->subjectPublicKeyInfo));

	if(COMPONENTBITS_PRESENT ((&v->issuerUniqueIdentifier)))
    {
	FreeComponentUniqueIdentifier((&v->issuerUniqueIdentifier));
	free ((v->issuerUniqueIdentifier).comp_desc);

	}

	if(COMPONENTBITS_PRESENT ((&v->subjectUniqueIdentifier)))
    {
	FreeComponentUniqueIdentifier((&v->subjectUniqueIdentifier));
	free ((v->subjectUniqueIdentifier).comp_desc);

	}

	if(COMPONENTNOT_NULL ((v->extensions)))
    {
	FreeComponentExtensions((v->extensions));
	free ((v->extensions)->comp_desc);
	free ((v->extensions));

	}

}  /* FreeTBSCertificate */


int
MatchingComponentCertificate ( char* oid, ComponentSyntaxInfo* csi_attr, ComponentSyntaxInfo* csi_assert ) {
	int rc;
	MatchingRule* mr;

	if ( oid ) {
		mr = retrieve_matching_rule( oid, csi_attr->csi_comp_desc->cd_type_id);
		if ( mr ) return component_value_match( mr, csi_attr, csi_assert );
	}

	rc = 1;
	rc =	MatchingComponentTBSCertificate ( oid, (ComponentSyntaxInfo*)((ComponentCertificate*)csi_attr)->tbsCertificate, (ComponentSyntaxInfo*)((ComponentCertificate*)csi_assert)->tbsCertificate );
	if ( rc != LDAP_COMPARE_TRUE )
		return rc;
	rc =	MatchingComponentAlgorithmIdentifier ( oid, (ComponentSyntaxInfo*)((ComponentCertificate*)csi_attr)->signatureAlgorithm, (ComponentSyntaxInfo*)((ComponentCertificate*)csi_assert)->signatureAlgorithm );
	if ( rc != LDAP_COMPARE_TRUE )
		return rc;
	rc =	MatchingComponentBits ( oid, (ComponentSyntaxInfo*)&((ComponentCertificate*)csi_attr)->signature, (ComponentSyntaxInfo*)&((ComponentCertificate*)csi_assert)->signature );
	if ( rc != LDAP_COMPARE_TRUE )
		return rc;
	return LDAP_COMPARE_TRUE;
}  /* BMatchingComponentCertificate */

void*
ExtractingComponentCertificate ( ComponentReference* cr, ComponentCertificate *comp )
{

	if ( ( strncmp(comp->tbsCertificate->identifier.bv_val, cr->cr_curr->ci_val.ci_identifier.bv_val,cr->cr_curr->ci_val.ci_identifier.bv_len) == 0 ) || ( strncmp(comp->tbsCertificate->id_buf, cr->cr_curr->ci_val.ci_identifier.bv_val,cr->cr_curr->ci_val.ci_identifier.bv_len) == 0 ) ) {
		if ( cr->cr_curr->ci_next == NULL )
			return comp->tbsCertificate;
		else {
			cr->cr_curr = cr->cr_curr->ci_next;
			return 	ExtractingComponentTBSCertificate ( cr, comp->tbsCertificate );
		}
	}
	if ( ( strncmp(comp->signatureAlgorithm->identifier.bv_val, cr->cr_curr->ci_val.ci_identifier.bv_val,cr->cr_curr->ci_val.ci_identifier.bv_len) == 0 ) || ( strncmp(comp->signatureAlgorithm->id_buf, cr->cr_curr->ci_val.ci_identifier.bv_val,cr->cr_curr->ci_val.ci_identifier.bv_len) == 0 ) ) {
		if ( cr->cr_curr->ci_next == NULL )
			return comp->signatureAlgorithm;
		else {
			cr->cr_curr = cr->cr_curr->ci_next;
			return 	ExtractingComponentAlgorithmIdentifier ( cr, comp->signatureAlgorithm );
		}
	}
	if ( ( strncmp(comp->signature.identifier.bv_val, cr->cr_curr->ci_val.ci_identifier.bv_val,cr->cr_curr->ci_val.ci_identifier.bv_len) == 0 ) || ( strncmp(comp->signature.id_buf, cr->cr_curr->ci_val.ci_identifier.bv_val,cr->cr_curr->ci_val.ci_identifier.bv_len) == 0 ) ) {
		if ( cr->cr_curr->ci_next == NULL )
		return &comp->signature;
		else
		return NULL;
	}
	return NULL;
}  /* ExtractingComponentCertificate */

int
BDecComponentCertificate PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, mode),
GenBuf * b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
ComponentCertificate **v _AND_
AsnLen *bytesDecoded _AND_
int mode)
{
    int seqDone = FALSE, old_mode = mode;
	AsnLen totalElmtsLen1 = 0;
	AsnLen elmtLen1;
	AsnTag tagId1;
	int mandatoryElmtCount1 = 0;
	ComponentCertificate *k, *t, c_temp;


	if ( !(mode & DEC_ALLOC_MODE_1) ) {
	memset(&c_temp,0,sizeof(c_temp));
		 k = &c_temp;
	} else
		 k = t = *v;
	mode = DEC_ALLOC_MODE_2;
    tagId1 = BDecTag (b, &totalElmtsLen1 );

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1 );
	BDecComponentTBSCertificate (b, tagId1, elmtLen1, (&k->tbsCertificate), &totalElmtsLen1, mode);
		(k->tbsCertificate)->identifier.bv_val = (k->tbsCertificate)->id_buf;
		(k->tbsCertificate)->identifier.bv_len = strlen("tbsCertificate");
		strcpy( (k->tbsCertificate)->identifier.bv_val, "tbsCertificate");
    tagId1 = BDecTag (b, &totalElmtsLen1);
    }
    else
        return -1;



    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1 );
	BDecComponentAlgorithmIdentifier (b, tagId1, elmtLen1, (&k->signatureAlgorithm), &totalElmtsLen1, mode);
		(k->signatureAlgorithm)->identifier.bv_val = (k->signatureAlgorithm)->id_buf;
		(k->signatureAlgorithm)->identifier.bv_len = strlen("signatureAlgorithm");
		strcpy( (k->signatureAlgorithm)->identifier.bv_val, "signatureAlgorithm");
    tagId1 = BDecTag (b, &totalElmtsLen1);
    }
    else
        return -1;



    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, BITSTRING_TAG_CODE)) ||
(tagId1 == MAKE_TAG_ID (UNIV, CONS, BITSTRING_TAG_CODE))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1 );
	BDecComponentBits (b, tagId1, elmtLen1, (&k->signature), &totalElmtsLen1, mode);
		(&k->signature)->identifier.bv_val = (&k->signature)->id_buf;
		(&k->signature)->identifier.bv_len = strlen("signature");
		strcpy( (&k->signature)->identifier.bv_val, "signature");
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1 );
        else if (totalElmtsLen1 != elmtLen0)
        return -1;

    }
    else
        return -1;



    if (!seqDone)
        return -1;

	if( !(old_mode & DEC_ALLOC_MODE_1) ) {
	*v = t = (ComponentCertificate*) malloc( sizeof(ComponentCertificate) );
	if ( !t ) return -1;
	*t = *k;
	}
	t->syntax = (Syntax*)NULL;
	t->comp_desc = malloc( sizeof( ComponentDesc ) );
	if ( !t->comp_desc ) {
		free ( t );
		return -1;
	}
	t->comp_desc->cd_gser_decoder = (gser_decoder_func*)GDecComponentCertificate ;
	t->comp_desc->cd_ber_decoder = (ber_decoder_func*)BDecComponentCertificate ;
	t->comp_desc->cd_free = (comp_free_func*)FreeComponentCertificate ;
	t->comp_desc->cd_extract_i = (extract_component_from_id_func*)ExtractingComponentCertificate;
	t->comp_desc->cd_type = ASN_COMPOSITE;
	t->comp_desc->cd_type_id = COMPOSITE_ASN1_TYPE;
	t->comp_desc->cd_all_match = (allcomponent_matching_func*)MatchingComponentCertificate;
    (*bytesDecoded) += totalElmtsLen1;
	return LDAP_SUCCESS;
}  /* BDecCertificate*/

int
GDecComponentCertificate PARAMS ((b, v, bytesDecoded, mode),
GenBuf * b _AND_
ComponentCertificate **v _AND_
AsnLen *bytesDecoded _AND_
int mode)
{
	char* peek_head,*peek_head2;
	int i, strLen,strLen2, rc, old_mode = mode;
	ComponentCertificate *k,*t, c_temp;


	if ( !(mode & DEC_ALLOC_MODE_1) ) {
	memset(&c_temp,0,sizeof(c_temp));
		 k = &c_temp;
	} else
		 k = t = *v;
	mode = DEC_ALLOC_MODE_2;
	*bytesDecoded = 0;
	if( !(strLen = LocateNextGSERToken(b,&peek_head,GSER_NO_COPY)) ){
		Asn1Error("Error during Reading , in encoded data");
		return LDAP_PROTOCOL_ERROR;
	}
	if(*peek_head != '{'){
		Asn1Error("Missing { in encoded data");
		return LDAP_PROTOCOL_ERROR;
	}
	if( !(strLen = LocateNextGSERToken(b,&peek_head,GSER_NO_COPY)) ){
	  Asn1Error("Error during Reading identifier");
		return LDAP_PROTOCOL_ERROR;
	}
	GDecComponentTBSCertificate (b, (&k->tbsCertificate), bytesDecoded, mode);
	( k->tbsCertificate)->identifier.bv_val = peek_head;
	( k->tbsCertificate)->identifier.bv_len = strLen;
	if( !(strLen = LocateNextGSERToken(b,&peek_head,GSER_NO_COPY)) ){
		Asn1Error("Error during Reading { ");
		return LDAP_PROTOCOL_ERROR;
	}
	if(*peek_head != ','){
		Asn1Error("Missing , in encoding");
		return LDAP_PROTOCOL_ERROR;
	}
	if( !(strLen = LocateNextGSERToken(b,&peek_head,GSER_NO_COPY)) ){
	  Asn1Error("Error during Reading identifier");
		return LDAP_PROTOCOL_ERROR;
	}
	GDecComponentAlgorithmIdentifier (b, (&k->signatureAlgorithm), bytesDecoded, mode);
	( k->signatureAlgorithm)->identifier.bv_val = peek_head;
	( k->signatureAlgorithm)->identifier.bv_len = strLen;
	if( !(strLen = LocateNextGSERToken(b,&peek_head,GSER_NO_COPY)) ){
		Asn1Error("Error during Reading { ");
		return LDAP_PROTOCOL_ERROR;
	}
	if(*peek_head != ','){
		Asn1Error("Missing , in encoding");
		return LDAP_PROTOCOL_ERROR;
	}
	if( !(strLen = LocateNextGSERToken(b,&peek_head,GSER_NO_COPY)) ){
	  Asn1Error("Error during Reading identifier");
		return LDAP_PROTOCOL_ERROR;
	}
	GDecComponentBits (b, (&k->signature), bytesDecoded, mode);
	(&k->signature)->identifier.bv_val = peek_head;
	(&k->signature)->identifier.bv_len = strLen;
	if( !(strLen = LocateNextGSERToken(b,&peek_head,GSER_NO_COPY)) ) {
		Asn1Error("Error during Reading } in encoding");
		return LDAP_PROTOCOL_ERROR;
	}
	if(*peek_head != '}'){
		Asn1Error("Missing } in encoding");
		return LDAP_PROTOCOL_ERROR;
	}
	if( !(old_mode & DEC_ALLOC_MODE_1) ) {
	*v = t = (ComponentCertificate*) malloc( sizeof(ComponentCertificate) );
	if ( !t ) return -1;
	*t = *k;
	}
	t->syntax = (Syntax*)NULL;
	t->comp_desc = malloc( sizeof( ComponentDesc ) );
	if ( !t->comp_desc ) {
		free ( t );
		return -1;
	}
	t->comp_desc->cd_gser_decoder = (gser_decoder_func*)GDecComponentCertificate ;
	t->comp_desc->cd_ber_decoder = (ber_decoder_func*)BDecComponentCertificate ;
	t->comp_desc->cd_free = (comp_free_func*)FreeComponentCertificate ;
	t->comp_desc->cd_extract_i = (extract_component_from_id_func*)ExtractingComponentCertificate;
	t->comp_desc->cd_type = ASN_COMPOSITE;
	t->comp_desc->cd_type_id = COMPOSITE_ASN1_TYPE;
	t->comp_desc->cd_all_match = (allcomponent_matching_func*)MatchingComponentCertificate;
	return LDAP_SUCCESS;
}  /* GDecCertificate*/

void FreeComponentCertificate(ComponentCertificate *v)
{

	if(v == NULL)
		return;
	FreeComponentTBSCertificate((v->tbsCertificate));
	free ((v->tbsCertificate)->comp_desc);
	free ((v->tbsCertificate));

	FreeComponentAlgorithmIdentifier((v->signatureAlgorithm));
	free ((v->signatureAlgorithm)->comp_desc);
	free ((v->signatureAlgorithm));

	FreeComponentBits((&v->signature));
	free ((v->signature).comp_desc);

}  /* FreeCertificate */


